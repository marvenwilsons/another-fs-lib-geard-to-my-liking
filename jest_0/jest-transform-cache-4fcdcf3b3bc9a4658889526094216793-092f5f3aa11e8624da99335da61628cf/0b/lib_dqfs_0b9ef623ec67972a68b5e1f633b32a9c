110f391bffa46aad2f7587ece2b5b8ca
"use strict";

const fs = require('fs');
const queryString = require('querystring');
const d = (() => {
    // Current Data set 
    const dir = {
        name: undefined,
        publicPath: undefined,
        parentDir: undefined,
        label: undefined,
        items: undefined,
        size: undefined,
        type: undefined, // directory or file
        fileAccess: undefined,
        birttime: undefined
        // init empty lib
    };let lib = {};
    let cd = undefined;
    lib.rootPath = undefined;
    // Utils
    function ArgsParamTypeError(message) {
        this.message = message;
    }
    function PathDoesNotExistError(message) {
        this.message = message;
    }
    function ERROR(message) {
        this.message = message;
    }
    function err(message) {
        throw new ERROR(message);
    }
    function isUndef(val, fnName) {
        let y = [];
        val.forEach(el => {
            y.push(el == undefined);
        });
        if (y.indexOf(true) != -1) {
            throw {
                message: `${fnName} function arg position ${y.indexOf(true)} cannot be undefined`
            };
        }
    }
    function isType(types, fnName, t) {
        isUndef([types, fnName, t], fnName);

        if (types.indexOf(false) == -1) {
            return true;
        } else {
            throw new ArgsParamTypeError(`on ${fnName}() function argument position (${types.indexOf(false) + 1}) cannot be undefined should be a ${t[types.indexOf(false)]}`);
        }
    }
    function isEmpty(val, fn) {
        if (val == '') {
            throw {
                message: `${fn} function cannot take an empty string as an argument`
            };
        }
    }
    function getSize(path) {
        let totalSize = 0;

        // recursion
        const recur = path => {
            let isThereADir = [];
            fs.lstatSync(path).isDirectory() ? isThereADir = fs.readdirSync(path) : totalSize += fs.lstatSync(path).size;
            isThereADir.length != 0 && isThereADir.map(e => recur(`${path}/${e}`));
        };

        // initial call
        recur(path);

        return totalSize;
    }
    function getChildPaths(path) {
        let children = {
            dir: [],
            files: []
        };
        const isD = fs.statSync(path).isDirectory() ? true : false;
        const items = isD ? fs.readdirSync(path) : path;
        typeof items == 'object' ? items.map(e => children.dir.push(`${path}${e}`)) : children.files.push(items);
        return children;
    }
    function setC(T) {
        let newA = [];
        cd = fs.readdirSync(T);
        cd.forEach(child => {
            const G = Object.create(dir);
            G.name = child;
            G.publicPath = `${T}${child}`;
            G.parentDir = T;
            G.label = 'none';
            G.items = fs.lstatSync(`${T}${child}`).isDirectory() ? G.items = fs.readdirSync(`${T}${child}`).length : G.items = 'none';
            G.size = getSize(`${T}${child}`);
            G.birthtime = fs.lstatSync(T).birthtime;
            G.type = fs.lstatSync(`${T}/${child}`).isDirectory() ? 'folder/directory' : 'file/application';
            G.children = getChildPaths(`${T}${child}`).length == 0 ? 'none' : getChildPaths(`${T}${child}`);
            G.fileAccess = 'rw+';
            if (fs.lstatSync(`${T}${child}`).isDirectory()) {
                delete G.fileAccess;
                G.folderAccess = 'rw+';
            } else {
                delete G.items;
                G.fileAccess = 'rw+';
            }
            newA.push(G);
        });
        cd = newA;
    }
    const Layer = function (data, { beforeEnter, hasEntered, onExit }) {
        const bE = beforeEnter(data);
        const oE = hasEntered(bE);
        onExit(oE);
    };
    // libs

    // a. set rooth path directory
    lib.cd = path => {
        isType([[typeof path] == 'string'], 'cd', ['string']);
        isEmpty(path, 'cd');

        const sanitizedPath = path.endsWith('/') ? path : `${path}/`;

        if (fs.existsSync(sanitizedPath)) {
            lib.rootPath = sanitizedPath;
            setC(sanitizedPath);
        } else {
            throw {
                message: `cd: no such directory ${sanitizedPath}`
            };
        }
        return true;
    };

    // b. retunrs an array of properties, of folder contents
    lib.ls = (absolutePath, options) => {
        // case 1, absolutepath is object, so the path that well be used
        //         to travers the directory is the cd path,
        //         it is expected that the object has object keys for options array
        const objFirstArg = typeof absolutePath == 'object' && options == undefined && absolutePath;

        // case 2, absolutepath is string, it means the user provided an absolute path
        //         which means the cd path if it is being set will be ignored
        const stringFirstArg = typeof absolutePath == 'string' && options == undefined && true;

        // case 3, 
        const completeArgs = typeof absolutePath == 'string' && typeof options == 'object';

        // case 4
        const allUndef = absolutePath == undefined && options == undefined;

        // options error
        const optionsErr = err => {
            throw { message: err };
        };

        // switch base on what case the user take
        const opts = objFirstArg ? objFirstArg : options;
        const opts2 = stringFirstArg ? absolutePath : opts;
        const opts3 = completeArgs ? options : opts2;
        const opts4 = allUndef && lib.rootPath;
        const optsRes = opts4 ? opts4 : opts3;

        // toggle types
        let currentType = 'object';
        const changeType = type => currentType = type;
        stringFirstArg && changeType('string');
        completeArgs && changeType('object');
        allUndef && changeType('string');

        // This the only available options, this is the keys that the user will provide
        const optionsArray = ['endsWith', 'startsWith', 'wildCard'];
        Object.seal(optionsArray);

        // rootPath is not set and absolutePath is not
        lib.rootPath == undefined && absolutePath == undefined && optionsErr(`ls: Path cannot be undefined, at least set a roothPath`);

        // if option is not a type of object throw an error | ls()
        typeof optsRes != currentType && optionsErr(`ls: Options should be a type of ${currentType} only`);

        // if options object is empty throw an error | ls({})
        typeof opts == currentType && Object.keys(opts).length == 0 && optionsErr(`listError: Options ${currentType} cannot be empty`);

        // if options object has more than one key throw an error
        typeof opts == currentType && Object.keys(opts).length != 1 && optionsErr('listError: Options object cannot be more than one');

        // typo in the options key
        typeof opts == currentType && Object.keys(opts).length == 1 && optionsArray.indexOf(Object.keys(opts)[0]) == -1 && optionsErr(`listError: "${Object.keys(opts)[0]}" is not recognized, options are "${optionsArray}"`);

        // empty value
        typeof opts == currentType && Object.keys(opts).length == 1 && optionsArray.indexOf(Object.keys(opts)[0]) != -1 && opts[Object.keys(opts)[0]] == '' && optionsErr('listError: Options value cannot be an empty string');

        // not a string value
        typeof opts == 'object' && Object.keys(opts).length == 1 && optionsArray.indexOf(Object.keys(opts)[0]) != -1 && typeof opts[Object.keys(opts)[0]] != 'string' && optionsErr('listError: Options value type should be a string');

        // Container that will be use to be mutated later, used to for return of the data
        let res = undefined;

        // returned methods
        let methods = {};

        // modes 
        const modes = ['asc', 'dec'];

        // UseData
        let UserData = undefined;
        objFirstArg && (UserData = { path: lib.rootPath, options: absolutePath });
        // stringFirstArg  && (UserData = {path: absolutePath.endsWith('/') ? absolutePath : `${absolutePath}/`, options:undefined})

        // what if cd link has the same link as ls ? 
        const strFirstArgC1 = typeof lib.rootPath == 'string' && typeof absolutePath == 'string';
        const strFirstArgC2 = strFirstArgC1 && lib.rootPath == absolutePath ? true : false;
        const strFirstArgC3 = strFirstArgC2 ? absolutePath : `${lib.rootPath == undefined ? '' : lib.rootPath}${absolutePath}`;

        // assign correct data
        stringFirstArg && (UserData = { path: strFirstArgC3.endsWith('/') ? strFirstArgC3 : `${strFirstArgC3}/`, options: undefined });
        completeArgs && (UserData = { path: strFirstArgC3.endsWith('/') ? strFirstArgC3 : `${strFirstArgC3}/`, options });
        allUndef && (UserData = { path: lib.rootPath, options: options });

        // Contents
        let contents = [];
        const doesPathExist = fs.existsSync(UserData.path);
        if (!doesPathExist) {
            throw new PathDoesNotExistError(`on ls: no such directory ${UserData.path}`);
        }
        doesPathExist && setC(UserData.path);

        return cd;
    };

    //
    lib.touch = file => {
        // sanitizing
        file == undefined && err('error touch: touch parameter cannot be undefined');
        typeof file != 'string' && file[0] == undefined && err('error touch: invalid tpye in parameter should be a string or array');

        const c1 = () => {
            const originPath = Object.keys(queryString.parse(file, '/'));
            const pathLen = originPath.length - 1;
            const pathFile = `/${originPath.splice(pathLen, 1)[0]}`;
            originPath.splice(pathLen, 1);
            let newPath = '';
            originPath.map(e => newPath += `/${e}`);

            fs.existsSync(newPath) ? fs.existsSync(`${newPath}${pathFile}`) ? err(`${pathFile} already exist in ${newPath} directory`) : fs.writeFileSync(`${newPath}${pathFile}`) : err(`there is no such directory ${newPath}`);

            return true;
        };

        c1();

        // console.log(`${file} --> ${lib.rootPath}`)

        // checking existancce
    };

    // c. mkdir creates new directory
    // c.cases : mkdir([]) --> accepts array as an arugument as folder names | mass folder creation
    // c.cases : mkdir('') --> accepts string | single dir creation
    lib.mkdir = path => {};

    delete lib.rootPath;
    return lib;
})();

module.exports = d;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYl9kcWZzLmpzIl0sIm5hbWVzIjpbImZzIiwicmVxdWlyZSIsInF1ZXJ5U3RyaW5nIiwiZCIsImRpciIsIm5hbWUiLCJ1bmRlZmluZWQiLCJwdWJsaWNQYXRoIiwicGFyZW50RGlyIiwibGFiZWwiLCJpdGVtcyIsInNpemUiLCJ0eXBlIiwiZmlsZUFjY2VzcyIsImJpcnR0aW1lIiwibGliIiwiY2QiLCJyb290UGF0aCIsIkFyZ3NQYXJhbVR5cGVFcnJvciIsIm1lc3NhZ2UiLCJQYXRoRG9lc05vdEV4aXN0RXJyb3IiLCJFUlJPUiIsImVyciIsImlzVW5kZWYiLCJ2YWwiLCJmbk5hbWUiLCJ5IiwiZm9yRWFjaCIsImVsIiwicHVzaCIsImluZGV4T2YiLCJpc1R5cGUiLCJ0eXBlcyIsInQiLCJpc0VtcHR5IiwiZm4iLCJnZXRTaXplIiwicGF0aCIsInRvdGFsU2l6ZSIsInJlY3VyIiwiaXNUaGVyZUFEaXIiLCJsc3RhdFN5bmMiLCJpc0RpcmVjdG9yeSIsInJlYWRkaXJTeW5jIiwibGVuZ3RoIiwibWFwIiwiZSIsImdldENoaWxkUGF0aHMiLCJjaGlsZHJlbiIsImZpbGVzIiwiaXNEIiwic3RhdFN5bmMiLCJzZXRDIiwiVCIsIm5ld0EiLCJjaGlsZCIsIkciLCJPYmplY3QiLCJjcmVhdGUiLCJiaXJ0aHRpbWUiLCJmb2xkZXJBY2Nlc3MiLCJMYXllciIsImRhdGEiLCJiZWZvcmVFbnRlciIsImhhc0VudGVyZWQiLCJvbkV4aXQiLCJiRSIsIm9FIiwic2FuaXRpemVkUGF0aCIsImVuZHNXaXRoIiwiZXhpc3RzU3luYyIsImxzIiwiYWJzb2x1dGVQYXRoIiwib3B0aW9ucyIsIm9iakZpcnN0QXJnIiwic3RyaW5nRmlyc3RBcmciLCJjb21wbGV0ZUFyZ3MiLCJhbGxVbmRlZiIsIm9wdGlvbnNFcnIiLCJvcHRzIiwib3B0czIiLCJvcHRzMyIsIm9wdHM0Iiwib3B0c1JlcyIsImN1cnJlbnRUeXBlIiwiY2hhbmdlVHlwZSIsIm9wdGlvbnNBcnJheSIsInNlYWwiLCJrZXlzIiwicmVzIiwibWV0aG9kcyIsIm1vZGVzIiwiVXNlckRhdGEiLCJzdHJGaXJzdEFyZ0MxIiwic3RyRmlyc3RBcmdDMiIsInN0ckZpcnN0QXJnQzMiLCJjb250ZW50cyIsImRvZXNQYXRoRXhpc3QiLCJ0b3VjaCIsImZpbGUiLCJjMSIsIm9yaWdpblBhdGgiLCJwYXJzZSIsInBhdGhMZW4iLCJwYXRoRmlsZSIsInNwbGljZSIsIm5ld1BhdGgiLCJ3cml0ZUZpbGVTeW5jIiwibWtkaXIiLCJtb2R1bGUiLCJleHBvcnRzIl0sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQSxNQUFNQSxLQUFLQyxRQUFRLElBQVIsQ0FBWDtBQUNBLE1BQU1DLGNBQWNELFFBQVEsYUFBUixDQUFwQjtBQUNBLE1BQU1FLElBQUksQ0FBQyxNQUFNO0FBQ2pCO0FBQ0ksVUFBTUMsTUFBTTtBQUNSQyxjQUFNQyxTQURFO0FBRVJDLG9CQUFZRCxTQUZKO0FBR1JFLG1CQUFXRixTQUhIO0FBSVJHLGVBQU9ILFNBSkM7QUFLUkksZUFBT0osU0FMQztBQU1SSyxjQUFNTCxTQU5FO0FBT1JNLGNBQU1OLFNBUEUsRUFPUztBQUNqQk8sb0JBQVlQLFNBUko7QUFTUlEsa0JBQVVSO0FBRWxCO0FBWGdCLEtBQVosQ0FZQSxJQUFJUyxNQUFNLEVBQVY7QUFDQSxRQUFJQyxLQUFLVixTQUFUO0FBQ0FTLFFBQUlFLFFBQUosR0FBZVgsU0FBZjtBQUNKO0FBQ0ksYUFBU1ksa0JBQVQsQ0FBNEJDLE9BQTVCLEVBQXFDO0FBQ2pDLGFBQUtBLE9BQUwsR0FBZUEsT0FBZjtBQUNIO0FBQ0QsYUFBU0MscUJBQVQsQ0FBK0JELE9BQS9CLEVBQXdDO0FBQ3BDLGFBQUtBLE9BQUwsR0FBZUEsT0FBZjtBQUNIO0FBQ0QsYUFBU0UsS0FBVCxDQUFlRixPQUFmLEVBQXVCO0FBQ25CLGFBQUtBLE9BQUwsR0FBZUEsT0FBZjtBQUNIO0FBQ0QsYUFBU0csR0FBVCxDQUFhSCxPQUFiLEVBQXNCO0FBQ2xCLGNBQU0sSUFBSUUsS0FBSixDQUFVRixPQUFWLENBQU47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QXlDbEYsSUFBSyxHQUFFa0YsUUFBUyxxQkFBb0JFLE9BQVEsWUFBNUMsQ0FBekMsR0FDQTFHLEdBQUcyRyxhQUFILENBQWtCLEdBQUVELE9BQVEsR0FBRUYsUUFBUyxFQUF2QyxDQUZKLEdBR0dsRixJQUFLLDhCQUE2Qm9GLE9BQVEsRUFBMUMsQ0FISDs7QUFLQSxtQkFBTyxJQUFQO0FBQ0gsU0FkRDs7QUFnQkFOOztBQUVBOztBQUVBO0FBRUgsS0E1QkQ7O0FBOEJBO0FBQ0E7QUFDQTtBQUNBckYsUUFBSTZGLEtBQUosR0FBYXZFLElBQUQsSUFBVSxDQUVyQixDQUZEOztBQUlBLFdBQU90QixJQUFJRSxRQUFYO0FBQ0EsV0FBT0YsR0FBUDtBQUNILENBbFJTLEdBQVY7O0FBb1JBOEYsT0FBT0MsT0FBUCxHQUFpQjNHLENBQWpCIiwiZmlsZSI6ImxpYl9kcWZzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCJcblxuY29uc3QgZnMgPSByZXF1aXJlKCdmcycpXG5jb25zdCBxdWVyeVN0cmluZyA9IHJlcXVpcmUoJ3F1ZXJ5c3RyaW5nJylcbmNvbnN0IGQgPSAoKCkgPT4ge1xuLy8gQ3VycmVudCBEYXRhIHNldCBcbiAgICBjb25zdCBkaXIgPSB7XG4gICAgICAgIG5hbWU6IHVuZGVmaW5lZCxcbiAgICAgICAgcHVibGljUGF0aDogdW5kZWZpbmVkLFxuICAgICAgICBwYXJlbnREaXI6IHVuZGVmaW5lZCxcbiAgICAgICAgbGFiZWw6IHVuZGVmaW5lZCxcbiAgICAgICAgaXRlbXM6IHVuZGVmaW5lZCxcbiAgICAgICAgc2l6ZTogdW5kZWZpbmVkLFxuICAgICAgICB0eXBlOiB1bmRlZmluZWQsIC8vIGRpcmVjdG9yeSBvciBmaWxlXG4gICAgICAgIGZpbGVBY2Nlc3M6IHVuZGVmaW5lZCxcbiAgICAgICAgYmlydHRpbWU6IHVuZGVmaW5lZCxcbiAgICB9XG4vLyBpbml0IGVtcHR5IGxpYlxuICAgIGxldCBsaWIgPSB7fVxuICAgIGxldCBjZCA9IHVuZGVmaW5lZFxuICAgIGxpYi5yb290UGF0aCA9IHVuZGVmaW5lZFxuLy8gVXRpbHNcbiAgICBmdW5jdGlvbiBBcmdzUGFyYW1UeXBlRXJyb3IobWVzc2FnZSkge1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlXG4gICAgfVxuICAgIGZ1bmN0aW9uIFBhdGhEb2VzTm90RXhpc3RFcnJvcihtZXNzYWdlKSB7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2VcbiAgICB9XG4gICAgZnVuY3Rpb24gRVJST1IobWVzc2FnZSl7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2VcbiAgICB9XG4gICAgZnVuY3Rpb24gZXJyKG1lc3NhZ2UpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVSUk9SKG1lc3NhZ2UpXG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzVW5kZWYodmFsLGZuTmFtZSl7XG4gICAgICAgIGxldCB5ID0gW11cbiAgICAgICAgdmFsLmZvckVhY2goZWwgPT4ge1xuICAgICAgICAgICAgeS5wdXNoKGVsID09IHVuZGVmaW5lZClcbiAgICAgICAgfSlcbiAgICAgICAgaWYoeS5pbmRleE9mKHRydWUpICE9IC0xKXtcbiAgICAgICAgICAgIHRocm93e1xuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGAke2ZuTmFtZX0gZnVuY3Rpb24gYXJnIHBvc2l0aW9uICR7eS5pbmRleE9mKHRydWUpfSBjYW5ub3QgYmUgdW5kZWZpbmVkYFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzVHlwZSh0eXBlcyxmbk5hbWUsdCl7XG4gICAgICAgIGlzVW5kZWYoW3R5cGVzLGZuTmFtZSx0XSxmbk5hbWUpXG5cbiAgICAgICAgaWYodHlwZXMuaW5kZXhPZihmYWxzZSkgPT0gLTEpe1xuICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXJnc1BhcmFtVHlwZUVycm9yKFxuICAgICAgICAgICAgICAgIGBvbiAke2ZuTmFtZX0oKSBmdW5jdGlvbiBhcmd1bWVudCBwb3NpdGlvbiAoJHt0eXBlcy5pbmRleE9mKGZhbHNlKSArIDF9KSBjYW5ub3QgYmUgdW5kZWZpbmVkIHNob3VsZCBiZSBhICR7dFt0eXBlcy5pbmRleE9mKGZhbHNlKV19YFxuICAgICAgICAgICAgKVxuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzRW1wdHkodmFsLGZuKXtcbiAgICAgICAgaWYodmFsID09ICcnKXtcbiAgICAgICAgICAgIHRocm93IHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBgJHtmbn0gZnVuY3Rpb24gY2Fubm90IHRha2UgYW4gZW1wdHkgc3RyaW5nIGFzIGFuIGFyZ3VtZW50YFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldFNpemUocGF0aCl7XG4gICAgICAgIGxldCB0b3RhbFNpemUgID0gMCAgIFxuXG4gICAgICAgIC8vIHJlY3Vyc2lvblxuICAgICAgICBjb25zdCByZWN1ciA9IHBhdGggPT4ge1xuICAgICAgICAgICAgbGV0IGlzVGhlcmVBRGlyID0gW11cbiAgICAgICAgICAgIGZzLmxzdGF0U3luYyhwYXRoKS5pc0RpcmVjdG9yeSgpID8gKGlzVGhlcmVBRGlyID0gZnMucmVhZGRpclN5bmMocGF0aCkpIDogdG90YWxTaXplICs9IGZzLmxzdGF0U3luYyhwYXRoKS5zaXplXG4gICAgICAgICAgICBpc1RoZXJlQURpci5sZW5ndGggIT0gMCAmJiBpc1RoZXJlQURpci5tYXAoZSA9PiByZWN1cihgJHtwYXRofS8ke2V9YCkpXG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIGluaXRpYWwgY2FsbFxuICAgICAgICByZWN1cihwYXRoKVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHRvdGFsU2l6ZVxuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRDaGlsZFBhdGhzKHBhdGgpe1xuICAgICAgICBsZXQgY2hpbGRyZW4gPSB7XG4gICAgICAgICAgICBkaXI6IFtdLFxuICAgICAgICAgICAgZmlsZXM6IFtdXG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaXNEID0gZnMuc3RhdFN5bmMocGF0aCkuaXNEaXJlY3RvcnkoKSA/IHRydWUgOiBmYWxzZVxuICAgICAgICBjb25zdCBpdGVtcyA9IGlzRCA/IGZzLnJlYWRkaXJTeW5jKHBhdGgpIDogcGF0aCAgICAgICAgXG4gICAgICAgIHR5cGVvZiBpdGVtcyA9PSAnb2JqZWN0JyA/IGl0ZW1zLm1hcChlID0+IGNoaWxkcmVuLmRpci5wdXNoKGAke3BhdGh9JHtlfWApKSA6IGNoaWxkcmVuLmZpbGVzLnB1c2goaXRlbXMpXG4gICAgICAgIHJldHVybiBjaGlsZHJlblxuICAgIH1cbiAgICBmdW5jdGlvbiBzZXRDKFQpe1xuICAgICAgICBsZXQgbmV3QSA9IFtdXG4gICAgICAgIGNkID0gZnMucmVhZGRpclN5bmMoVClcbiAgICAgICAgY2QuZm9yRWFjaChjaGlsZCA9PiB7XG4gICAgICAgICAgICBjb25zdCBHID0gT2JqZWN0LmNyZWF0ZShkaXIpXG4gICAgICAgICAgICBHLm5hbWUgPSBjaGlsZFxuICAgICAgICAgICAgRy5wdWJsaWNQYXRoID0gYCR7VH0ke2NoaWxkfWBcbiAgICAgICAgICAgIEcucGFyZW50RGlyID0gVFxuICAgICAgICAgICAgRy5sYWJlbCA9ICdub25lJ1xuICAgICAgICAgICAgRy5pdGVtcyA9IGZzLmxzdGF0U3luYyhgJHtUfSR7Y2hpbGR9YCkuaXNEaXJlY3RvcnkoKSA/IEcuaXRlbXMgPSBmcy5yZWFkZGlyU3luYyhgJHtUfSR7Y2hpbGR9YCkubGVuZ3RoIDogRy5pdGVtcyA9ICdub25lJ1xuICAgICAgICAgICAgRy5zaXplID0gZ2V0U2l6ZShgJHtUfSR7Y2hpbGR9YClcbiAgICAgICAgICAgIEcuYmlydGh0aW1lID0gZnMubHN0YXRTeW5jKFQpLmJpcnRodGltZVxuICAgICAgICAgICAgRy50eXBlID0gZnMubHN0YXRTeW5jKGAke1R9LyR7Y2hpbGR9YCkuaXNEaXJlY3RvcnkoKSA/ICdmb2xkZXIvZGlyZWN0b3J5JyA6ICdmaWxlL2FwcGxpY2F0aW9uJ1xuICAgICAgICAgICAgRy5jaGlsZHJlbiA9IGdldENoaWxkUGF0aHMoYCR7VH0ke2NoaWxkfWApLmxlbmd0aCA9PSAwID8gJ25vbmUnIDogZ2V0Q2hpbGRQYXRocyhgJHtUfSR7Y2hpbGR9YClcbiAgICAgICAgICAgIEcuZmlsZUFjY2VzcyA9ICdydysnXG4gICAgICAgICAgICBpZihmcy5sc3RhdFN5bmMoIGAke1R9JHtjaGlsZH1gICkuaXNEaXJlY3RvcnkoKSApe1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBHLmZpbGVBY2Nlc3NcbiAgICAgICAgICAgICAgICBHLmZvbGRlckFjY2VzcyA9ICdydysnXG4gICAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgICAgICBkZWxldGUgRy5pdGVtc1xuICAgICAgICAgICAgICAgIEcuZmlsZUFjY2VzcyA9ICdydysnXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXdBLnB1c2goRylcbiAgICAgICAgfSlcbiAgICAgICAgY2QgPSBuZXdBXG4gICAgfVxuICAgIGNvbnN0IExheWVyID0gZnVuY3Rpb24oZGF0YSx7YmVmb3JlRW50ZXIsaGFzRW50ZXJlZCxvbkV4aXR9KSB7XG4gICAgICAgIGNvbnN0IGJFID0gYmVmb3JlRW50ZXIoZGF0YSlcbiAgICAgICAgY29uc3Qgb0UgPSBoYXNFbnRlcmVkKGJFKVxuICAgICAgICBvbkV4aXQob0UpXG4gICAgfVxuLy8gbGlic1xuICAgIFxuICAgIC8vIGEuIHNldCByb290aCBwYXRoIGRpcmVjdG9yeVxuICAgIGxpYi5jZCA9IChwYXRoKSA9PiB7ICAgICAgICBcbiAgICAgICAgaXNUeXBlKFtcbiAgICAgICAgICAgIFt0eXBlb2YgcGF0aF0gPT0gJ3N0cmluZydcbiAgICAgICAgXSwnY2QnLFsnc3RyaW5nJ10pXG4gICAgICAgIGlzRW1wdHkocGF0aCwnY2QnKVxuICAgICAgICBcbiAgICAgICAgY29uc3Qgc2FuaXRpemVkUGF0aCA9IHBhdGguZW5kc1dpdGgoJy8nKSA/IHBhdGggOiBgJHtwYXRofS9gXG4gICAgICAgIFxuICAgICAgICBpZihmcy5leGlzdHNTeW5jKHNhbml0aXplZFBhdGgpKXsgICAgICAgICAgICBcbiAgICAgICAgICAgIGxpYi5yb290UGF0aCA9IHNhbml0aXplZFBhdGhcbiAgICAgICAgICAgIHNldEMoc2FuaXRpemVkUGF0aClcbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICB0aHJvd3tcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBgY2Q6IG5vIHN1Y2ggZGlyZWN0b3J5ICR7c2FuaXRpemVkUGF0aH1gXG4gICAgICAgICAgICB9XG4gICAgICAgIH0gICAgICAgIFxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICBcbiAgICAvLyBiLiByZXR1bnJzIGFuIGFycmF5IG9mIHByb3BlcnRpZXMsIG9mIGZvbGRlciBjb250ZW50c1xuICAgIGxpYi5scyA9IChhYnNvbHV0ZVBhdGgsb3B0aW9ucykgPT4ge1xuICAgICAgICAvLyBjYXNlIDEsIGFic29sdXRlcGF0aCBpcyBvYmplY3QsIHNvIHRoZSBwYXRoIHRoYXQgd2VsbCBiZSB1c2VkXG4gICAgICAgIC8vICAgICAgICAgdG8gdHJhdmVycyB0aGUgZGlyZWN0b3J5IGlzIHRoZSBjZCBwYXRoLFxuICAgICAgICAvLyAgICAgICAgIGl0IGlzIGV4cGVjdGVkIHRoYXQgdGhlIG9iamVjdCBoYXMgb2JqZWN0IGtleXMgZm9yIG9wdGlvbnMgYXJyYXlcbiAgICAgICAgY29uc3Qgb2JqRmlyc3RBcmcgPSB0eXBlb2YgYWJzb2x1dGVQYXRoID09ICdvYmplY3QnICYmIG9wdGlvbnMgPT0gdW5kZWZpbmVkICYmIGFic29sdXRlUGF0aFxuXG4gICAgICAgIC8vIGNhc2UgMiwgYWJzb2x1dGVwYXRoIGlzIHN0cmluZywgaXQgbWVhbnMgdGhlIHVzZXIgcHJvdmlkZWQgYW4gYWJzb2x1dGUgcGF0aFxuICAgICAgICAvLyAgICAgICAgIHdoaWNoIG1lYW5zIHRoZSBjZCBwYXRoIGlmIGl0IGlzIGJlaW5nIHNldCB3aWxsIGJlIGlnbm9yZWRcbiAgICAgICAgY29uc3Qgc3RyaW5nRmlyc3RBcmcgPSB0eXBlb2YgYWJzb2x1dGVQYXRoID09ICdzdHJpbmcnICYmIG9wdGlvbnMgPT0gdW5kZWZpbmVkICYmIHRydWVcblxuICAgICAgICAvLyBjYXNlIDMsIFxuICAgICAgICBjb25zdCBjb21wbGV0ZUFyZ3MgPSB0eXBlb2YgYWJzb2x1dGVQYXRoID09ICdzdHJpbmcnICYmIHR5cGVvZiBvcHRpb25zID09ICdvYmplY3QnXG5cbiAgICAgICAgLy8gY2FzZSA0XG4gICAgICAgIGNvbnN0IGFsbFVuZGVmID0gYWJzb2x1dGVQYXRoID09IHVuZGVmaW5lZCAmJiBvcHRpb25zID09IHVuZGVmaW5lZFxuXG4gICAgICAgIC8vIG9wdGlvbnMgZXJyb3JcbiAgICAgICAgY29uc3Qgb3B0aW9uc0VyciA9IChlcnIpID0+IHt0aHJvdyB7bWVzc2FnZTogZXJyfX1cblxuICAgICAgICAvLyBzd2l0Y2ggYmFzZSBvbiB3aGF0IGNhc2UgdGhlIHVzZXIgdGFrZVxuICAgICAgICBjb25zdCBvcHRzID0gb2JqRmlyc3RBcmcgPyBvYmpGaXJzdEFyZyA6IG9wdGlvbnNcbiAgICAgICAgY29uc3Qgb3B0czIgPSBzdHJpbmdGaXJzdEFyZyA/IGFic29sdXRlUGF0aCA6IG9wdHNcbiAgICAgICAgY29uc3Qgb3B0czMgPSBjb21wbGV0ZUFyZ3MgPyBvcHRpb25zIDogb3B0czJcbiAgICAgICAgY29uc3Qgb3B0czQgPSBhbGxVbmRlZiAmJiBsaWIucm9vdFBhdGhcbiAgICAgICAgY29uc3Qgb3B0c1JlcyA9IG9wdHM0ID8gb3B0czQgOiBvcHRzM1xuICAgICAgICBcbiAgICAgICAgLy8gdG9nZ2xlIHR5cGVzXG4gICAgICAgIGxldCBjdXJyZW50VHlwZSA9ICdvYmplY3QnXG4gICAgICAgIGNvbnN0IGNoYW5nZVR5cGUgPSAodHlwZSkgPT4gY3VycmVudFR5cGUgPSB0eXBlXG4gICAgICAgIHN0cmluZ0ZpcnN0QXJnICYmIGNoYW5nZVR5cGUoJ3N0cmluZycpXG4gICAgICAgIGNvbXBsZXRlQXJncyAmJiBjaGFuZ2VUeXBlKCdvYmplY3QnKVxuICAgICAgICBhbGxVbmRlZiAmJiBjaGFuZ2VUeXBlKCdzdHJpbmcnKVxuXG4gICAgICAgIC8vIFRoaXMgdGhlIG9ubHkgYXZhaWxhYmxlIG9wdGlvbnMsIHRoaXMgaXMgdGhlIGtleXMgdGhhdCB0aGUgdXNlciB3aWxsIHByb3ZpZGVcbiAgICAgICAgY29uc3Qgb3B0aW9uc0FycmF5ID0gWydlbmRzV2l0aCcsJ3N0YXJ0c1dpdGgnLCd3aWxkQ2FyZCddXG4gICAgICAgIE9iamVjdC5zZWFsKG9wdGlvbnNBcnJheSlcblxuICAgICAgICAvLyByb290UGF0aCBpcyBub3Qgc2V0IGFuZCBhYnNvbHV0ZVBhdGggaXMgbm90XG4gICAgICAgIGxpYi5yb290UGF0aCA9PSB1bmRlZmluZWQgJiYgYWJzb2x1dGVQYXRoID09IHVuZGVmaW5lZCAmJiBvcHRpb25zRXJyKGBsczogUGF0aCBjYW5ub3QgYmUgdW5kZWZpbmVkLCBhdCBsZWFzdCBzZXQgYSByb290aFBhdGhgKVxuXG4gICAgICAgIC8vIGlmIG9wdGlvbiBpcyBub3QgYSB0eXBlIG9mIG9iamVjdCB0aHJvdyBhbiBlcnJvciB8IGxzKClcbiAgICAgICAgdHlwZW9mIG9wdHNSZXMgIT0gY3VycmVudFR5cGUgJiYgb3B0aW9uc0VycihgbHM6IE9wdGlvbnMgc2hvdWxkIGJlIGEgdHlwZSBvZiAke2N1cnJlbnRUeXBlfSBvbmx5YClcblxuICAgICAgICAvLyBpZiBvcHRpb25zIG9iamVjdCBpcyBlbXB0eSB0aHJvdyBhbiBlcnJvciB8IGxzKHt9KVxuICAgICAgICB0eXBlb2Ygb3B0cyA9PSBjdXJyZW50VHlwZSAmJiBPYmplY3Qua2V5cyhvcHRzKS5sZW5ndGggPT0gMCAmJiBvcHRpb25zRXJyKGBsaXN0RXJyb3I6IE9wdGlvbnMgJHtjdXJyZW50VHlwZX0gY2Fubm90IGJlIGVtcHR5YClcblxuICAgICAgICAvLyBpZiBvcHRpb25zIG9iamVjdCBoYXMgbW9yZSB0aGFuIG9uZSBrZXkgdGhyb3cgYW4gZXJyb3JcbiAgICAgICAgdHlwZW9mIG9wdHMgPT0gY3VycmVudFR5cGUgJiYgT2JqZWN0LmtleXMob3B0cykubGVuZ3RoICE9IDEgJiYgb3B0aW9uc0VycignbGlzdEVycm9yOiBPcHRpb25zIG9iamVjdCBjYW5ub3QgYmUgbW9yZSB0aGFuIG9uZScpXG5cbiAgICAgICAgLy8gdHlwbyBpbiB0aGUgb3B0aW9ucyBrZXlcbiAgICAgICAgdHlwZW9mIG9wdHMgPT0gY3VycmVudFR5cGUgJiYgT2JqZWN0LmtleXMob3B0cykubGVuZ3RoID09IDEgJiYgXG4gICAgICAgIG9wdGlvbnNBcnJheS5pbmRleE9mKE9iamVjdC5rZXlzKG9wdHMpWzBdKSA9PSAtMSAmJiBvcHRpb25zRXJyKGBsaXN0RXJyb3I6IFwiJHtPYmplY3Qua2V5cyhvcHRzKVswXX1cIiBpcyBub3QgcmVjb2duaXplZCwgb3B0aW9ucyBhcmUgXCIke29wdGlvbnNBcnJheX1cImApXG4gICAgICAgIFxuICAgICAgICAvLyBlbXB0eSB2YWx1ZVxuICAgICAgICB0eXBlb2Ygb3B0cyA9PSBjdXJyZW50VHlwZSAmJiBPYmplY3Qua2V5cyhvcHRzKS5sZW5ndGggPT0gMSAmJlxuICAgICAgICBvcHRpb25zQXJyYXkuaW5kZXhPZihPYmplY3Qua2V5cyhvcHRzKVswXSkgIT0gLTEgJiYgb3B0c1tPYmplY3Qua2V5cyhvcHRzKVswXV0gPT0gJycgJiYgXG4gICAgICAgIG9wdGlvbnNFcnIoJ2xpc3RFcnJvcjogT3B0aW9ucyB2YWx1ZSBjYW5ub3QgYmUgYW4gZW1wdHkgc3RyaW5nJylcblxuICAgICAgICAvLyBub3QgYSBzdHJpbmcgdmFsdWVcbiAgICAgICAgdHlwZW9mIG9wdHMgPT0gJ29iamVjdCcgJiYgT2JqZWN0LmtleXMob3B0cykubGVuZ3RoID09IDEgJiZcbiAgICAgICAgb3B0aW9uc0FycmF5LmluZGV4T2YoT2JqZWN0LmtleXMob3B0cylbMF0pICE9IC0xICYmIHR5cGVvZiBvcHRzW09iamVjdC5rZXlzKG9wdHMpWzBdXSAhPSAnc3RyaW5nJyAmJiBcbiAgICAgICAgb3B0aW9uc0VycignbGlzdEVycm9yOiBPcHRpb25zIHZhbHVlIHR5cGUgc2hvdWxkIGJlIGEgc3RyaW5nJylcblxuICAgICAgICAvLyBDb250YWluZXIgdGhhdCB3aWxsIGJlIHVzZSB0byBiZSBtdXRhdGVkIGxhdGVyLCB1c2VkIHRvIGZvciByZXR1cm4gb2YgdGhlIGRhdGFcbiAgICAgICAgbGV0IHJlcyA9IHVuZGVmaW5lZFxuXG4gICAgICAgIC8vIHJldHVybmVkIG1ldGhvZHNcbiAgICAgICAgbGV0IG1ldGhvZHMgPSB7fVxuXG4gICAgICAgIC8vIG1vZGVzIFxuICAgICAgICBjb25zdCBtb2RlcyA9IFsnYXNjJywnZGVjJ11cblxuICAgICAgICAvLyBVc2VEYXRhXG4gICAgICAgIGxldCBVc2VyRGF0YSA9IHVuZGVmaW5lZFxuICAgICAgICBvYmpGaXJzdEFyZyAgICAgJiYgKFVzZXJEYXRhID0ge3BhdGg6IGxpYi5yb290UGF0aCwgb3B0aW9uczphYnNvbHV0ZVBhdGh9KVxuICAgICAgICAvLyBzdHJpbmdGaXJzdEFyZyAgJiYgKFVzZXJEYXRhID0ge3BhdGg6IGFic29sdXRlUGF0aC5lbmRzV2l0aCgnLycpID8gYWJzb2x1dGVQYXRoIDogYCR7YWJzb2x1dGVQYXRofS9gLCBvcHRpb25zOnVuZGVmaW5lZH0pXG5cbiAgICAgICAgLy8gd2hhdCBpZiBjZCBsaW5rIGhhcyB0aGUgc2FtZSBsaW5rIGFzIGxzID8gXG4gICAgICAgIGNvbnN0IHN0ckZpcnN0QXJnQzEgPSB0eXBlb2YgbGliLnJvb3RQYXRoID09ICdzdHJpbmcnICYmIHR5cGVvZiBhYnNvbHV0ZVBhdGggPT0gJ3N0cmluZydcbiAgICAgICAgY29uc3Qgc3RyRmlyc3RBcmdDMiA9IHN0ckZpcnN0QXJnQzEgJiYgbGliLnJvb3RQYXRoID09IGFic29sdXRlUGF0aCA/IHRydWUgOiBmYWxzZVxuICAgICAgICBjb25zdCBzdHJGaXJzdEFyZ0MzID0gc3RyRmlyc3RBcmdDMiA/IGFic29sdXRlUGF0aCA6IGAke2xpYi5yb290UGF0aCA9PSB1bmRlZmluZWQgPyAnJyA6IGxpYi5yb290UGF0aH0ke2Fic29sdXRlUGF0aH1gXG5cbiAgICAgICAgLy8gYXNzaWduIGNvcnJlY3QgZGF0YVxuICAgICAgICBzdHJpbmdGaXJzdEFyZyAgJiYgKFVzZXJEYXRhID0ge3BhdGg6IHN0ckZpcnN0QXJnQzMuZW5kc1dpdGgoJy8nKSA/IHN0ckZpcnN0QXJnQzMgOiBgJHtzdHJGaXJzdEFyZ0MzfS9gLCBvcHRpb25zOnVuZGVmaW5lZH0pXG4gICAgICAgIGNvbXBsZXRlQXJncyAgICAmJiAoVXNlckRhdGEgPSB7cGF0aDogc3RyRmlyc3RBcmdDMy5lbmRzV2l0aCgnLycpID8gc3RyRmlyc3RBcmdDMyA6IGAke3N0ckZpcnN0QXJnQzN9L2AsIG9wdGlvbnN9KVxuICAgICAgICBhbGxVbmRlZiAgICAgICAgJiYgKFVzZXJEYXRhID0ge3BhdGg6IGxpYi5yb290UGF0aCwgb3B0aW9uczpvcHRpb25zfSlcblxuICAgICAgICAvLyBDb250ZW50c1xuICAgICAgICBsZXQgY29udGVudHMgPSBbXVxuICAgICAgICBjb25zdCBkb2VzUGF0aEV4aXN0ID0gZnMuZXhpc3RzU3luYyhVc2VyRGF0YS5wYXRoKVxuICAgICAgICBpZighZG9lc1BhdGhFeGlzdCl7dGhyb3cgbmV3IFBhdGhEb2VzTm90RXhpc3RFcnJvcihgb24gbHM6IG5vIHN1Y2ggZGlyZWN0b3J5ICR7VXNlckRhdGEucGF0aH1gKX1cbiAgICAgICAgZG9lc1BhdGhFeGlzdCAmJiBzZXRDKFVzZXJEYXRhLnBhdGgpXG5cbiAgICAgICAgcmV0dXJuIGNkXG4gICAgfVxuXG4gICAgLy9cbiAgICBsaWIudG91Y2ggPSAoZmlsZSkgPT4ge1xuICAgICAgICAvLyBzYW5pdGl6aW5nXG4gICAgICAgIGZpbGUgPT0gdW5kZWZpbmVkICYmIGVycignZXJyb3IgdG91Y2g6IHRvdWNoIHBhcmFtZXRlciBjYW5ub3QgYmUgdW5kZWZpbmVkJylcbiAgICAgICAgdHlwZW9mIGZpbGUgIT0gJ3N0cmluZycgJiYgZmlsZVswXSA9PSB1bmRlZmluZWQgJiYgZXJyKCdlcnJvciB0b3VjaDogaW52YWxpZCB0cHllIGluIHBhcmFtZXRlciBzaG91bGQgYmUgYSBzdHJpbmcgb3IgYXJyYXknKVxuXG5cbiAgICAgICAgY29uc3QgYzEgPSAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBvcmlnaW5QYXRoID0gT2JqZWN0LmtleXMoIHF1ZXJ5U3RyaW5nLnBhcnNlKGZpbGUsJy8nKSApXG4gICAgICAgICAgICBjb25zdCBwYXRoTGVuID0gb3JpZ2luUGF0aC5sZW5ndGggLSAxXG4gICAgICAgICAgICBjb25zdCBwYXRoRmlsZSA9IGAvJHtvcmlnaW5QYXRoLnNwbGljZShwYXRoTGVuLDEpWzBdfWBcbiAgICAgICAgICAgIG9yaWdpblBhdGguc3BsaWNlKHBhdGhMZW4sMSlcbiAgICAgICAgICAgIGxldCBuZXdQYXRoID0gJydcbiAgICAgICAgICAgIG9yaWdpblBhdGgubWFwKGUgPT4gbmV3UGF0aCArPSBgLyR7ZX1gKVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBmcy5leGlzdHNTeW5jKG5ld1BhdGgpID8gXG4gICAgICAgICAgICAgICAgZnMuZXhpc3RzU3luYyhgJHtuZXdQYXRofSR7cGF0aEZpbGV9YCkgPyBlcnIoYCR7cGF0aEZpbGV9IGFscmVhZHkgZXhpc3QgaW4gJHtuZXdQYXRofSBkaXJlY3RvcnlgKSA6IFxuICAgICAgICAgICAgICAgIGZzLndyaXRlRmlsZVN5bmMoYCR7bmV3UGF0aH0ke3BhdGhGaWxlfWApXG4gICAgICAgICAgICA6ICBlcnIoYHRoZXJlIGlzIG5vIHN1Y2ggZGlyZWN0b3J5ICR7bmV3UGF0aH1gKVxuXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG5cbiAgICAgICAgYzEoKVxuICAgICAgICBcbiAgICAgICAgLy8gY29uc29sZS5sb2coYCR7ZmlsZX0gLS0+ICR7bGliLnJvb3RQYXRofWApXG4gICAgICAgIFxuICAgICAgICAvLyBjaGVja2luZyBleGlzdGFuY2NlXG4gICAgICAgIFxuICAgIH1cblxuICAgIC8vIGMuIG1rZGlyIGNyZWF0ZXMgbmV3IGRpcmVjdG9yeVxuICAgIC8vIGMuY2FzZXMgOiBta2RpcihbXSkgLS0+IGFjY2VwdHMgYXJyYXkgYXMgYW4gYXJ1Z3VtZW50IGFzIGZvbGRlciBuYW1lcyB8IG1hc3MgZm9sZGVyIGNyZWF0aW9uXG4gICAgLy8gYy5jYXNlcyA6IG1rZGlyKCcnKSAtLT4gYWNjZXB0cyBzdHJpbmcgfCBzaW5nbGUgZGlyIGNyZWF0aW9uXG4gICAgbGliLm1rZGlyID0gKHBhdGgpID0+IHtcblxuICAgIH1cblxuICAgIGRlbGV0ZSBsaWIucm9vdFBhdGhcbiAgICByZXR1cm4gbGliXG59KSgpXG5cbm1vZHVsZS5leHBvcnRzID0gZCJdfQ==