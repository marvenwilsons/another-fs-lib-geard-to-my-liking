40ec190f5755febfdc5c4176c2acd185
"use strict";

const fs = require('fs');
const queryString = require('querystring');
const d = (() => {
    // Current Data set 
    const dir = {
        name: undefined,
        publicPath: undefined,
        parentDir: undefined,
        label: undefined,
        items: undefined,
        size: undefined,
        type: undefined, // directory or file
        fileAccess: undefined,
        birttime: undefined
        // init empty lib
    };let lib = {};
    let cd = undefined;
    lib.rootPath = undefined;
    // Utils
    function ArgsParamTypeError(message) {
        this.message = message;
    }
    function PathDoesNotExistError(message) {
        this.message = message;
    }
    function ERROR(message) {
        this.message = message;
    }
    function err(message) {
        throw new ERROR(message);
    }
    function isUndef(val, fnName) {
        let y = [];
        val.forEach(el => {
            y.push(el == undefined);
        });
        if (y.indexOf(true) != -1) {
            throw {
                message: `${fnName} function arg position ${y.indexOf(true)} cannot be undefined`
            };
        }
    }
    function isType(types, fnName, t) {
        isUndef([types, fnName, t], fnName);

        if (types.indexOf(false) == -1) {
            return true;
        } else {
            throw new ArgsParamTypeError(`on ${fnName}() function argument position (${types.indexOf(false) + 1}) cannot be undefined should be a ${t[types.indexOf(false)]}`);
        }
    }
    function isEmpty(val, fn) {
        if (val == '') {
            throw {
                message: `${fn} function cannot take an empty string as an argument`
            };
        }
    }
    function getSize(path) {
        let totalSize = 0;

        // recursion
        const recur = path => {
            let isThereADir = [];
            fs.lstatSync(path).isDirectory() ? isThereADir = fs.readdirSync(path) : totalSize += fs.lstatSync(path).size;
            isThereADir.length != 0 && isThereADir.map(e => recur(`${path}/${e}`));
        };

        // initial call
        recur(path);

        return totalSize;
    }
    function getChildPaths(path) {
        let children = {
            dir: [],
            files: []
        };
        const isD = fs.statSync(path).isDirectory() ? true : false;
        const items = isD ? fs.readdirSync(path) : path;
        typeof items == 'object' ? items.map(e => children.dir.push(`${path}${e}`)) : children.files.push(items);
        return children;
    }
    function setC(T) {
        let newA = [];
        cd = fs.readdirSync(T);
        cd.forEach(child => {
            const G = Object.create(dir);
            G.name = child;
            G.publicPath = `${T}${child}`;
            G.parentDir = T;
            G.label = 'none';
            G.items = fs.lstatSync(`${T}${child}`).isDirectory() ? G.items = fs.readdirSync(`${T}${child}`).length : G.items = 'none';
            G.size = getSize(`${T}${child}`);
            G.birthtime = fs.lstatSync(T).birthtime;
            G.type = fs.lstatSync(`${T}/${child}`).isDirectory() ? 'folder/directory' : 'file/application';
            G.children = getChildPaths(`${T}${child}`).length == 0 ? 'none' : getChildPaths(`${T}${child}`);
            G.fileAccess = 'rw+';
            if (fs.lstatSync(`${T}${child}`).isDirectory()) {
                delete G.fileAccess;
                G.folderAccess = 'rw+';
            } else {
                delete G.items;
                G.fileAccess = 'rw+';
            }
            newA.push(G);
        });
        cd = newA;
    }
    const Layer = function (data, { beforeEnter, hasEntered, onExit }) {
        const bE = beforeEnter(data);
        const oE = hasEntered(bE);
        onExit(oE);
    };
    // libs

    // a. set rooth path directory
    lib.cd = path => {
        isType([[typeof path] == 'string'], 'cd', ['string']);
        isEmpty(path, 'cd');

        const sanitizedPath = path.endsWith('/') ? path : `${path}/`;

        if (fs.existsSync(sanitizedPath)) {
            lib.rootPath = sanitizedPath;
            setC(sanitizedPath);
        } else {
            throw {
                message: `cd: no such directory ${sanitizedPath}`
            };
        }
        return true;
    };

    // b. retunrs an array of properties, of folder contents
    lib.ls = (absolutePath, options) => {
        // case 1, absolutepath is object, so the path that well be used
        //         to travers the directory is the cd path,
        //         it is expected that the object has object keys for options array
        const objFirstArg = typeof absolutePath == 'object' && options == undefined && absolutePath;

        // case 2, absolutepath is string, it means the user provided an absolute path
        //         which means the cd path if it is being set will be ignored
        const stringFirstArg = typeof absolutePath == 'string' && options == undefined && true;

        // case 3, 
        const completeArgs = typeof absolutePath == 'string' && typeof options == 'object';

        // case 4
        const allUndef = absolutePath == undefined && options == undefined;

        // options error
        const optionsErr = err => {
            throw { message: err };
        };

        // switch base on what case the user take
        const opts = objFirstArg ? objFirstArg : options;
        const opts2 = stringFirstArg ? absolutePath : opts;
        const opts3 = completeArgs ? options : opts2;
        const opts4 = allUndef && lib.rootPath;
        const optsRes = opts4 ? opts4 : opts3;

        // toggle types
        let currentType = 'object';
        const changeType = type => currentType = type;
        stringFirstArg && changeType('string');
        completeArgs && changeType('object');
        allUndef && changeType('string');

        // This the only available options, this is the keys that the user will provide
        const optionsArray = ['endsWith', 'startsWith', 'wildCard'];
        Object.seal(optionsArray);

        // rootPath is not set and absolutePath is not
        lib.rootPath == undefined && absolutePath == undefined && optionsErr(`ls: Path cannot be undefined, at least set a roothPath`);

        // if option is not a type of object throw an error | ls()
        typeof optsRes != currentType && optionsErr(`ls: Options should be a type of ${currentType} only`);

        // if options object is empty throw an error | ls({})
        typeof opts == currentType && Object.keys(opts).length == 0 && optionsErr(`listError: Options ${currentType} cannot be empty`);

        // if options object has more than one key throw an error
        typeof opts == currentType && Object.keys(opts).length != 1 && optionsErr('listError: Options object cannot be more than one');

        // typo in the options key
        typeof opts == currentType && Object.keys(opts).length == 1 && optionsArray.indexOf(Object.keys(opts)[0]) == -1 && optionsErr(`listError: "${Object.keys(opts)[0]}" is not recognized, options are "${optionsArray}"`);

        // empty value
        typeof opts == currentType && Object.keys(opts).length == 1 && optionsArray.indexOf(Object.keys(opts)[0]) != -1 && opts[Object.keys(opts)[0]] == '' && optionsErr('listError: Options value cannot be an empty string');

        // not a string value
        typeof opts == 'object' && Object.keys(opts).length == 1 && optionsArray.indexOf(Object.keys(opts)[0]) != -1 && typeof opts[Object.keys(opts)[0]] != 'string' && optionsErr('listError: Options value type should be a string');

        // Container that will be use to be mutated later, used to for return of the data
        let res = undefined;

        // returned methods
        let methods = {};

        // modes 
        const modes = ['asc', 'dec'];

        // UseData
        let UserData = undefined;
        objFirstArg && (UserData = { path: lib.rootPath, options: absolutePath });
        // stringFirstArg  && (UserData = {path: absolutePath.endsWith('/') ? absolutePath : `${absolutePath}/`, options:undefined})

        // what if cd link has the same link as ls ? 
        const strFirstArgC1 = typeof lib.rootPath == 'string' && typeof absolutePath == 'string';
        const strFirstArgC2 = strFirstArgC1 && lib.rootPath == absolutePath ? true : false;
        const strFirstArgC3 = strFirstArgC2 ? absolutePath : `${lib.rootPath == undefined ? '' : lib.rootPath}${absolutePath}`;

        // assign correct data
        stringFirstArg && (UserData = { path: strFirstArgC3.endsWith('/') ? strFirstArgC3 : `${strFirstArgC3}/`, options: undefined });
        completeArgs && (UserData = { path: strFirstArgC3.endsWith('/') ? strFirstArgC3 : `${strFirstArgC3}/`, options });
        allUndef && (UserData = { path: lib.rootPath, options: options });

        // Contents
        let contents = [];
        const doesPathExist = fs.existsSync(UserData.path);
        if (!doesPathExist) {
            throw new PathDoesNotExistError(`on ls: no such directory ${UserData.path}`);
        }
        doesPathExist && setC(UserData.path);

        return cd;
    };

    //
    lib.touch = file => {
        // sanitizing
        file == undefined && err('error touch: touch parameter cannot be undefined');
        typeof file != 'string' && file[0] == undefined && err('error touch: invalid tpye in parameter should be a string or array');

        const c1 = () => {
            const originPath = Object.keys(queryString.parse(file, '/'));
            const pathLen = originPath.length - 1;
            const pathFile = `/${originPath.splice(pathLen, 1)[0]}`;
            originPath.splice(pathLen, 1);
            let newPath = '';
            originPath.map(e => newPath += `/${e}`);

            fs.existsSync(newPath) ? fs.existsSync(`${newPath}${pathFile}`) ? err(`${pathFile} already exist in ${newPath} directory`) : fs.writeFileSync(`${newPath}${pathFile}`) : err(`there is no such directory ${newPath}`);

            return true;
        };

        lib.rootPath == undefined && typeof file == 'string' && c1();

        // console.log(`${file} --> ${lib.rootPath}`)

        // checking existancce
    };

    // c. mkdir creates new directory
    // c.cases : mkdir([]) --> accepts array as an arugument as folder names | mass folder creation
    // c.cases : mkdir('') --> accepts string | single dir creation
    lib.mkdir = path => {};

    delete lib.rootPath;
    return lib;
})();

module.exports = d;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYl9kcWZzLmpzIl0sIm5hbWVzIjpbImZzIiwicmVxdWlyZSIsInF1ZXJ5U3RyaW5nIiwiZCIsImRpciIsIm5hbWUiLCJ1bmRlZmluZWQiLCJwdWJsaWNQYXRoIiwicGFyZW50RGlyIiwibGFiZWwiLCJpdGVtcyIsInNpemUiLCJ0eXBlIiwiZmlsZUFjY2VzcyIsImJpcnR0aW1lIiwibGliIiwiY2QiLCJyb290UGF0aCIsIkFyZ3NQYXJhbVR5cGVFcnJvciIsIm1lc3NhZ2UiLCJQYXRoRG9lc05vdEV4aXN0RXJyb3IiLCJFUlJPUiIsImVyciIsImlzVW5kZWYiLCJ2YWwiLCJmbk5hbWUiLCJ5IiwiZm9yRWFjaCIsImVsIiwicHVzaCIsImluZGV4T2YiLCJpc1R5cGUiLCJ0eXBlcyIsInQiLCJpc0VtcHR5IiwiZm4iLCJnZXRTaXplIiwicGF0aCIsInRvdGFsU2l6ZSIsInJlY3VyIiwiaXNUaGVyZUFEaXIiLCJsc3RhdFN5bmMiLCJpc0RpcmVjdG9yeSIsInJlYWRkaXJTeW5jIiwibGVuZ3RoIiwibWFwIiwiZSIsImdldENoaWxkUGF0aHMiLCJjaGlsZHJlbiIsImZpbGVzIiwiaXNEIiwic3RhdFN5bmMiLCJzZXRDIiwiVCIsIm5ld0EiLCJjaGlsZCIsIkciLCJPYmplY3QiLCJjcmVhdGUiLCJiaXJ0aHRpbWUiLCJmb2xkZXJBY2Nlc3MiLCJMYXllciIsImRhdGEiLCJiZWZvcmVFbnRlciIsImhhc0VudGVyZWQiLCJvbkV4aXQiLCJiRSIsIm9FIiwic2FuaXRpemVkUGF0aCIsImVuZHNXaXRoIiwiZXhpc3RzU3luYyIsImxzIiwiYWJzb2x1dGVQYXRoIiwib3B0aW9ucyIsIm9iakZpcnN0QXJnIiwic3RyaW5nRmlyc3RBcmciLCJjb21wbGV0ZUFyZ3MiLCJhbGxVbmRlZiIsIm9wdGlvbnNFcnIiLCJvcHRzIiwib3B0czIiLCJvcHRzMyIsIm9wdHM0Iiwib3B0c1JlcyIsImN1cnJlbnRUeXBlIiwiY2hhbmdlVHlwZSIsIm9wdGlvbnNBcnJheSIsInNlYWwiLCJrZXlzIiwicmVzIiwibWV0aG9kcyIsIm1vZGVzIiwiVXNlckRhdGEiLCJzdHJGaXJzdEFyZ0MxIiwic3RyRmlyc3RBcmdDMiIsInN0ckZpcnN0QXJnQzMiLCJjb250ZW50cyIsImRvZXNQYXRoRXhpc3QiLCJ0b3VjaCIsImZpbGUiLCJjMSIsIm9yaWdpblBhdGgiLCJwYXJzZSIsInBhdGhMZW4iLCJwYXRoRmlsZSIsInNwbGljZSIsIm5ld1BhdGgiLCJ3cml0ZUZpbGVTeW5jIiwibWtkaXIiLCJtb2R1bGUiLCJleHBvcnRzIl0sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQSxNQUFNQSxLQUFLQyxRQUFRLElBQVIsQ0FBWDtBQUNBLE1BQU1DLGNBQWNELFFBQVEsYUFBUixDQUFwQjtBQUNBLE1BQU1FLElBQUksQ0FBQyxNQUFNO0FBQ2pCO0FBQ0ksVUFBTUMsTUFBTTtBQUNSQyxjQUFNQyxTQURFO0FBRVJDLG9CQUFZRCxTQUZKO0FBR1JFLG1CQUFXRixTQUhIO0FBSVJHLGVBQU9ILFNBSkM7QUFLUkksZUFBT0osU0FMQztBQU1SSyxjQUFNTCxTQU5FO0FBT1JNLGNBQU1OLFNBUEUsRUFPUztBQUNqQk8sb0JBQVlQLFNBUko7QUFTUlEsa0JBQVVSO0FBRWxCO0FBWGdCLEtBQVosQ0FZQSxJQUFJUyxNQUFNLEVBQVY7QUFDQSxRQUFJQyxLQUFLVixTQUFUO0FBQ0FTLFFBQUlFLFFBQUosR0FBZVgsU0FBZjtBQUNKO0FBQ0ksYUFBU1ksa0JBQVQsQ0FBNEJDLE9BQTVCLEVBQXFDO0FBQ2pDLGFBQUtBLE9BQUwsR0FBZUEsT0FBZjtBQUNIO0FBQ0QsYUFBU0MscUJBQVQsQ0FBK0JELE9BQS9CLEVBQXdDO0FBQ3BDLGFBQUtBLE9BQUwsR0FBZUEsT0FBZjtBQUNIO0FBQ0QsYUFBU0UsS0FBVCxDQUFlRixPQUFmLEVBQXVCO0FBQ25CLGFBQUtBLE9BQUwsR0FBZUEsT0FBZjtBQUNIO0FBQ0QsYUFBU0csR0FBVCxDQUFhSCxPQUFiLEVBQXNCO0FBQ2xCLGNBQU0sSUFBSUUsS0FBSixDQUFVRixPQUFWLENBQU47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QXlDbEYsSUFBSyxHQUFFa0YsUUFBUyxxQkFBb0JFLE9BQVEsWUFBNUMsQ0FBekMsR0FDQTFHLEdBQUcyRyxhQUFILENBQWtCLEdBQUVELE9BQVEsR0FBRUYsUUFBUyxFQUF2QyxDQUZKLEdBR0dsRixJQUFLLDhCQUE2Qm9GLE9BQVEsRUFBMUMsQ0FISDs7QUFLQSxtQkFBTyxJQUFQO0FBQ0gsU0FkRDs7QUFnQkEzRixZQUFJRSxRQUFKLElBQWdCWCxTQUFoQixJQUE2QixPQUFPNkYsSUFBUCxJQUFlLFFBQTVDLElBQXdEQyxJQUF4RDs7QUFFQTs7QUFFQTtBQUVILEtBNUJEOztBQThCQTtBQUNBO0FBQ0E7QUFDQXJGLFFBQUk2RixLQUFKLEdBQWF2RSxJQUFELElBQVUsQ0FFckIsQ0FGRDs7QUFJQSxXQUFPdEIsSUFBSUUsUUFBWDtBQUNBLFdBQU9GLEdBQVA7QUFDSCxDQWxSUyxHQUFWOztBQW9SQThGLE9BQU9DLE9BQVAsR0FBaUIzRyxDQUFqQiIsImZpbGUiOiJsaWJfZHFmcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiXG5cbmNvbnN0IGZzID0gcmVxdWlyZSgnZnMnKVxuY29uc3QgcXVlcnlTdHJpbmcgPSByZXF1aXJlKCdxdWVyeXN0cmluZycpXG5jb25zdCBkID0gKCgpID0+IHtcbi8vIEN1cnJlbnQgRGF0YSBzZXQgXG4gICAgY29uc3QgZGlyID0ge1xuICAgICAgICBuYW1lOiB1bmRlZmluZWQsXG4gICAgICAgIHB1YmxpY1BhdGg6IHVuZGVmaW5lZCxcbiAgICAgICAgcGFyZW50RGlyOiB1bmRlZmluZWQsXG4gICAgICAgIGxhYmVsOiB1bmRlZmluZWQsXG4gICAgICAgIGl0ZW1zOiB1bmRlZmluZWQsXG4gICAgICAgIHNpemU6IHVuZGVmaW5lZCxcbiAgICAgICAgdHlwZTogdW5kZWZpbmVkLCAvLyBkaXJlY3Rvcnkgb3IgZmlsZVxuICAgICAgICBmaWxlQWNjZXNzOiB1bmRlZmluZWQsXG4gICAgICAgIGJpcnR0aW1lOiB1bmRlZmluZWQsXG4gICAgfVxuLy8gaW5pdCBlbXB0eSBsaWJcbiAgICBsZXQgbGliID0ge31cbiAgICBsZXQgY2QgPSB1bmRlZmluZWRcbiAgICBsaWIucm9vdFBhdGggPSB1bmRlZmluZWRcbi8vIFV0aWxzXG4gICAgZnVuY3Rpb24gQXJnc1BhcmFtVHlwZUVycm9yKG1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZVxuICAgIH1cbiAgICBmdW5jdGlvbiBQYXRoRG9lc05vdEV4aXN0RXJyb3IobWVzc2FnZSkge1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlXG4gICAgfVxuICAgIGZ1bmN0aW9uIEVSUk9SKG1lc3NhZ2Upe1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlXG4gICAgfVxuICAgIGZ1bmN0aW9uIGVycihtZXNzYWdlKSB7XG4gICAgICAgIHRocm93IG5ldyBFUlJPUihtZXNzYWdlKVxuICAgIH1cbiAgICBmdW5jdGlvbiBpc1VuZGVmKHZhbCxmbk5hbWUpe1xuICAgICAgICBsZXQgeSA9IFtdXG4gICAgICAgIHZhbC5mb3JFYWNoKGVsID0+IHtcbiAgICAgICAgICAgIHkucHVzaChlbCA9PSB1bmRlZmluZWQpXG4gICAgICAgIH0pXG4gICAgICAgIGlmKHkuaW5kZXhPZih0cnVlKSAhPSAtMSl7XG4gICAgICAgICAgICB0aHJvd3tcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBgJHtmbk5hbWV9IGZ1bmN0aW9uIGFyZyBwb3NpdGlvbiAke3kuaW5kZXhPZih0cnVlKX0gY2Fubm90IGJlIHVuZGVmaW5lZGBcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBpc1R5cGUodHlwZXMsZm5OYW1lLHQpe1xuICAgICAgICBpc1VuZGVmKFt0eXBlcyxmbk5hbWUsdF0sZm5OYW1lKVxuXG4gICAgICAgIGlmKHR5cGVzLmluZGV4T2YoZmFsc2UpID09IC0xKXtcbiAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1lbHNle1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3NQYXJhbVR5cGVFcnJvcihcbiAgICAgICAgICAgICAgICBgb24gJHtmbk5hbWV9KCkgZnVuY3Rpb24gYXJndW1lbnQgcG9zaXRpb24gKCR7dHlwZXMuaW5kZXhPZihmYWxzZSkgKyAxfSkgY2Fubm90IGJlIHVuZGVmaW5lZCBzaG91bGQgYmUgYSAke3RbdHlwZXMuaW5kZXhPZihmYWxzZSldfWBcbiAgICAgICAgICAgIClcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBpc0VtcHR5KHZhbCxmbil7XG4gICAgICAgIGlmKHZhbCA9PSAnJyl7XG4gICAgICAgICAgICB0aHJvdyB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZTogYCR7Zm59IGZ1bmN0aW9uIGNhbm5vdCB0YWtlIGFuIGVtcHR5IHN0cmluZyBhcyBhbiBhcmd1bWVudGBcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRTaXplKHBhdGgpe1xuICAgICAgICBsZXQgdG90YWxTaXplICA9IDAgICBcblxuICAgICAgICAvLyByZWN1cnNpb25cbiAgICAgICAgY29uc3QgcmVjdXIgPSBwYXRoID0+IHtcbiAgICAgICAgICAgIGxldCBpc1RoZXJlQURpciA9IFtdXG4gICAgICAgICAgICBmcy5sc3RhdFN5bmMocGF0aCkuaXNEaXJlY3RvcnkoKSA/IChpc1RoZXJlQURpciA9IGZzLnJlYWRkaXJTeW5jKHBhdGgpKSA6IHRvdGFsU2l6ZSArPSBmcy5sc3RhdFN5bmMocGF0aCkuc2l6ZVxuICAgICAgICAgICAgaXNUaGVyZUFEaXIubGVuZ3RoICE9IDAgJiYgaXNUaGVyZUFEaXIubWFwKGUgPT4gcmVjdXIoYCR7cGF0aH0vJHtlfWApKVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBpbml0aWFsIGNhbGxcbiAgICAgICAgcmVjdXIocGF0aClcbiAgICAgICAgXG4gICAgICAgIHJldHVybiB0b3RhbFNpemVcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0Q2hpbGRQYXRocyhwYXRoKXtcbiAgICAgICAgbGV0IGNoaWxkcmVuID0ge1xuICAgICAgICAgICAgZGlyOiBbXSxcbiAgICAgICAgICAgIGZpbGVzOiBbXVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlzRCA9IGZzLnN0YXRTeW5jKHBhdGgpLmlzRGlyZWN0b3J5KCkgPyB0cnVlIDogZmFsc2VcbiAgICAgICAgY29uc3QgaXRlbXMgPSBpc0QgPyBmcy5yZWFkZGlyU3luYyhwYXRoKSA6IHBhdGggICAgICAgIFxuICAgICAgICB0eXBlb2YgaXRlbXMgPT0gJ29iamVjdCcgPyBpdGVtcy5tYXAoZSA9PiBjaGlsZHJlbi5kaXIucHVzaChgJHtwYXRofSR7ZX1gKSkgOiBjaGlsZHJlbi5maWxlcy5wdXNoKGl0ZW1zKVxuICAgICAgICByZXR1cm4gY2hpbGRyZW5cbiAgICB9XG4gICAgZnVuY3Rpb24gc2V0QyhUKXtcbiAgICAgICAgbGV0IG5ld0EgPSBbXVxuICAgICAgICBjZCA9IGZzLnJlYWRkaXJTeW5jKFQpXG4gICAgICAgIGNkLmZvckVhY2goY2hpbGQgPT4ge1xuICAgICAgICAgICAgY29uc3QgRyA9IE9iamVjdC5jcmVhdGUoZGlyKVxuICAgICAgICAgICAgRy5uYW1lID0gY2hpbGRcbiAgICAgICAgICAgIEcucHVibGljUGF0aCA9IGAke1R9JHtjaGlsZH1gXG4gICAgICAgICAgICBHLnBhcmVudERpciA9IFRcbiAgICAgICAgICAgIEcubGFiZWwgPSAnbm9uZSdcbiAgICAgICAgICAgIEcuaXRlbXMgPSBmcy5sc3RhdFN5bmMoYCR7VH0ke2NoaWxkfWApLmlzRGlyZWN0b3J5KCkgPyBHLml0ZW1zID0gZnMucmVhZGRpclN5bmMoYCR7VH0ke2NoaWxkfWApLmxlbmd0aCA6IEcuaXRlbXMgPSAnbm9uZSdcbiAgICAgICAgICAgIEcuc2l6ZSA9IGdldFNpemUoYCR7VH0ke2NoaWxkfWApXG4gICAgICAgICAgICBHLmJpcnRodGltZSA9IGZzLmxzdGF0U3luYyhUKS5iaXJ0aHRpbWVcbiAgICAgICAgICAgIEcudHlwZSA9IGZzLmxzdGF0U3luYyhgJHtUfS8ke2NoaWxkfWApLmlzRGlyZWN0b3J5KCkgPyAnZm9sZGVyL2RpcmVjdG9yeScgOiAnZmlsZS9hcHBsaWNhdGlvbidcbiAgICAgICAgICAgIEcuY2hpbGRyZW4gPSBnZXRDaGlsZFBhdGhzKGAke1R9JHtjaGlsZH1gKS5sZW5ndGggPT0gMCA/ICdub25lJyA6IGdldENoaWxkUGF0aHMoYCR7VH0ke2NoaWxkfWApXG4gICAgICAgICAgICBHLmZpbGVBY2Nlc3MgPSAncncrJ1xuICAgICAgICAgICAgaWYoZnMubHN0YXRTeW5jKCBgJHtUfSR7Y2hpbGR9YCApLmlzRGlyZWN0b3J5KCkgKXtcbiAgICAgICAgICAgICAgICBkZWxldGUgRy5maWxlQWNjZXNzXG4gICAgICAgICAgICAgICAgRy5mb2xkZXJBY2Nlc3MgPSAncncrJ1xuICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICAgZGVsZXRlIEcuaXRlbXNcbiAgICAgICAgICAgICAgICBHLmZpbGVBY2Nlc3MgPSAncncrJ1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV3QS5wdXNoKEcpXG4gICAgICAgIH0pXG4gICAgICAgIGNkID0gbmV3QVxuICAgIH1cbiAgICBjb25zdCBMYXllciA9IGZ1bmN0aW9uKGRhdGEse2JlZm9yZUVudGVyLGhhc0VudGVyZWQsb25FeGl0fSkge1xuICAgICAgICBjb25zdCBiRSA9IGJlZm9yZUVudGVyKGRhdGEpXG4gICAgICAgIGNvbnN0IG9FID0gaGFzRW50ZXJlZChiRSlcbiAgICAgICAgb25FeGl0KG9FKVxuICAgIH1cbi8vIGxpYnNcbiAgICBcbiAgICAvLyBhLiBzZXQgcm9vdGggcGF0aCBkaXJlY3RvcnlcbiAgICBsaWIuY2QgPSAocGF0aCkgPT4geyAgICAgICAgXG4gICAgICAgIGlzVHlwZShbXG4gICAgICAgICAgICBbdHlwZW9mIHBhdGhdID09ICdzdHJpbmcnXG4gICAgICAgIF0sJ2NkJyxbJ3N0cmluZyddKVxuICAgICAgICBpc0VtcHR5KHBhdGgsJ2NkJylcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IHNhbml0aXplZFBhdGggPSBwYXRoLmVuZHNXaXRoKCcvJykgPyBwYXRoIDogYCR7cGF0aH0vYFxuICAgICAgICBcbiAgICAgICAgaWYoZnMuZXhpc3RzU3luYyhzYW5pdGl6ZWRQYXRoKSl7ICAgICAgICAgICAgXG4gICAgICAgICAgICBsaWIucm9vdFBhdGggPSBzYW5pdGl6ZWRQYXRoXG4gICAgICAgICAgICBzZXRDKHNhbml0aXplZFBhdGgpXG4gICAgICAgIH1lbHNle1xuICAgICAgICAgICAgdGhyb3d7XG4gICAgICAgICAgICAgICAgbWVzc2FnZTogYGNkOiBubyBzdWNoIGRpcmVjdG9yeSAke3Nhbml0aXplZFBhdGh9YFxuICAgICAgICAgICAgfVxuICAgICAgICB9ICAgICAgICBcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgXG4gICAgLy8gYi4gcmV0dW5ycyBhbiBhcnJheSBvZiBwcm9wZXJ0aWVzLCBvZiBmb2xkZXIgY29udGVudHNcbiAgICBsaWIubHMgPSAoYWJzb2x1dGVQYXRoLG9wdGlvbnMpID0+IHtcbiAgICAgICAgLy8gY2FzZSAxLCBhYnNvbHV0ZXBhdGggaXMgb2JqZWN0LCBzbyB0aGUgcGF0aCB0aGF0IHdlbGwgYmUgdXNlZFxuICAgICAgICAvLyAgICAgICAgIHRvIHRyYXZlcnMgdGhlIGRpcmVjdG9yeSBpcyB0aGUgY2QgcGF0aCxcbiAgICAgICAgLy8gICAgICAgICBpdCBpcyBleHBlY3RlZCB0aGF0IHRoZSBvYmplY3QgaGFzIG9iamVjdCBrZXlzIGZvciBvcHRpb25zIGFycmF5XG4gICAgICAgIGNvbnN0IG9iakZpcnN0QXJnID0gdHlwZW9mIGFic29sdXRlUGF0aCA9PSAnb2JqZWN0JyAmJiBvcHRpb25zID09IHVuZGVmaW5lZCAmJiBhYnNvbHV0ZVBhdGhcblxuICAgICAgICAvLyBjYXNlIDIsIGFic29sdXRlcGF0aCBpcyBzdHJpbmcsIGl0IG1lYW5zIHRoZSB1c2VyIHByb3ZpZGVkIGFuIGFic29sdXRlIHBhdGhcbiAgICAgICAgLy8gICAgICAgICB3aGljaCBtZWFucyB0aGUgY2QgcGF0aCBpZiBpdCBpcyBiZWluZyBzZXQgd2lsbCBiZSBpZ25vcmVkXG4gICAgICAgIGNvbnN0IHN0cmluZ0ZpcnN0QXJnID0gdHlwZW9mIGFic29sdXRlUGF0aCA9PSAnc3RyaW5nJyAmJiBvcHRpb25zID09IHVuZGVmaW5lZCAmJiB0cnVlXG5cbiAgICAgICAgLy8gY2FzZSAzLCBcbiAgICAgICAgY29uc3QgY29tcGxldGVBcmdzID0gdHlwZW9mIGFic29sdXRlUGF0aCA9PSAnc3RyaW5nJyAmJiB0eXBlb2Ygb3B0aW9ucyA9PSAnb2JqZWN0J1xuXG4gICAgICAgIC8vIGNhc2UgNFxuICAgICAgICBjb25zdCBhbGxVbmRlZiA9IGFic29sdXRlUGF0aCA9PSB1bmRlZmluZWQgJiYgb3B0aW9ucyA9PSB1bmRlZmluZWRcblxuICAgICAgICAvLyBvcHRpb25zIGVycm9yXG4gICAgICAgIGNvbnN0IG9wdGlvbnNFcnIgPSAoZXJyKSA9PiB7dGhyb3cge21lc3NhZ2U6IGVycn19XG5cbiAgICAgICAgLy8gc3dpdGNoIGJhc2Ugb24gd2hhdCBjYXNlIHRoZSB1c2VyIHRha2VcbiAgICAgICAgY29uc3Qgb3B0cyA9IG9iakZpcnN0QXJnID8gb2JqRmlyc3RBcmcgOiBvcHRpb25zXG4gICAgICAgIGNvbnN0IG9wdHMyID0gc3RyaW5nRmlyc3RBcmcgPyBhYnNvbHV0ZVBhdGggOiBvcHRzXG4gICAgICAgIGNvbnN0IG9wdHMzID0gY29tcGxldGVBcmdzID8gb3B0aW9ucyA6IG9wdHMyXG4gICAgICAgIGNvbnN0IG9wdHM0ID0gYWxsVW5kZWYgJiYgbGliLnJvb3RQYXRoXG4gICAgICAgIGNvbnN0IG9wdHNSZXMgPSBvcHRzNCA/IG9wdHM0IDogb3B0czNcbiAgICAgICAgXG4gICAgICAgIC8vIHRvZ2dsZSB0eXBlc1xuICAgICAgICBsZXQgY3VycmVudFR5cGUgPSAnb2JqZWN0J1xuICAgICAgICBjb25zdCBjaGFuZ2VUeXBlID0gKHR5cGUpID0+IGN1cnJlbnRUeXBlID0gdHlwZVxuICAgICAgICBzdHJpbmdGaXJzdEFyZyAmJiBjaGFuZ2VUeXBlKCdzdHJpbmcnKVxuICAgICAgICBjb21wbGV0ZUFyZ3MgJiYgY2hhbmdlVHlwZSgnb2JqZWN0JylcbiAgICAgICAgYWxsVW5kZWYgJiYgY2hhbmdlVHlwZSgnc3RyaW5nJylcblxuICAgICAgICAvLyBUaGlzIHRoZSBvbmx5IGF2YWlsYWJsZSBvcHRpb25zLCB0aGlzIGlzIHRoZSBrZXlzIHRoYXQgdGhlIHVzZXIgd2lsbCBwcm92aWRlXG4gICAgICAgIGNvbnN0IG9wdGlvbnNBcnJheSA9IFsnZW5kc1dpdGgnLCdzdGFydHNXaXRoJywnd2lsZENhcmQnXVxuICAgICAgICBPYmplY3Quc2VhbChvcHRpb25zQXJyYXkpXG5cbiAgICAgICAgLy8gcm9vdFBhdGggaXMgbm90IHNldCBhbmQgYWJzb2x1dGVQYXRoIGlzIG5vdFxuICAgICAgICBsaWIucm9vdFBhdGggPT0gdW5kZWZpbmVkICYmIGFic29sdXRlUGF0aCA9PSB1bmRlZmluZWQgJiYgb3B0aW9uc0VycihgbHM6IFBhdGggY2Fubm90IGJlIHVuZGVmaW5lZCwgYXQgbGVhc3Qgc2V0IGEgcm9vdGhQYXRoYClcblxuICAgICAgICAvLyBpZiBvcHRpb24gaXMgbm90IGEgdHlwZSBvZiBvYmplY3QgdGhyb3cgYW4gZXJyb3IgfCBscygpXG4gICAgICAgIHR5cGVvZiBvcHRzUmVzICE9IGN1cnJlbnRUeXBlICYmIG9wdGlvbnNFcnIoYGxzOiBPcHRpb25zIHNob3VsZCBiZSBhIHR5cGUgb2YgJHtjdXJyZW50VHlwZX0gb25seWApXG5cbiAgICAgICAgLy8gaWYgb3B0aW9ucyBvYmplY3QgaXMgZW1wdHkgdGhyb3cgYW4gZXJyb3IgfCBscyh7fSlcbiAgICAgICAgdHlwZW9mIG9wdHMgPT0gY3VycmVudFR5cGUgJiYgT2JqZWN0LmtleXMob3B0cykubGVuZ3RoID09IDAgJiYgb3B0aW9uc0VycihgbGlzdEVycm9yOiBPcHRpb25zICR7Y3VycmVudFR5cGV9IGNhbm5vdCBiZSBlbXB0eWApXG5cbiAgICAgICAgLy8gaWYgb3B0aW9ucyBvYmplY3QgaGFzIG1vcmUgdGhhbiBvbmUga2V5IHRocm93IGFuIGVycm9yXG4gICAgICAgIHR5cGVvZiBvcHRzID09IGN1cnJlbnRUeXBlICYmIE9iamVjdC5rZXlzKG9wdHMpLmxlbmd0aCAhPSAxICYmIG9wdGlvbnNFcnIoJ2xpc3RFcnJvcjogT3B0aW9ucyBvYmplY3QgY2Fubm90IGJlIG1vcmUgdGhhbiBvbmUnKVxuXG4gICAgICAgIC8vIHR5cG8gaW4gdGhlIG9wdGlvbnMga2V5XG4gICAgICAgIHR5cGVvZiBvcHRzID09IGN1cnJlbnRUeXBlICYmIE9iamVjdC5rZXlzKG9wdHMpLmxlbmd0aCA9PSAxICYmIFxuICAgICAgICBvcHRpb25zQXJyYXkuaW5kZXhPZihPYmplY3Qua2V5cyhvcHRzKVswXSkgPT0gLTEgJiYgb3B0aW9uc0VycihgbGlzdEVycm9yOiBcIiR7T2JqZWN0LmtleXMob3B0cylbMF19XCIgaXMgbm90IHJlY29nbml6ZWQsIG9wdGlvbnMgYXJlIFwiJHtvcHRpb25zQXJyYXl9XCJgKVxuICAgICAgICBcbiAgICAgICAgLy8gZW1wdHkgdmFsdWVcbiAgICAgICAgdHlwZW9mIG9wdHMgPT0gY3VycmVudFR5cGUgJiYgT2JqZWN0LmtleXMob3B0cykubGVuZ3RoID09IDEgJiZcbiAgICAgICAgb3B0aW9uc0FycmF5LmluZGV4T2YoT2JqZWN0LmtleXMob3B0cylbMF0pICE9IC0xICYmIG9wdHNbT2JqZWN0LmtleXMob3B0cylbMF1dID09ICcnICYmIFxuICAgICAgICBvcHRpb25zRXJyKCdsaXN0RXJyb3I6IE9wdGlvbnMgdmFsdWUgY2Fubm90IGJlIGFuIGVtcHR5IHN0cmluZycpXG5cbiAgICAgICAgLy8gbm90IGEgc3RyaW5nIHZhbHVlXG4gICAgICAgIHR5cGVvZiBvcHRzID09ICdvYmplY3QnICYmIE9iamVjdC5rZXlzKG9wdHMpLmxlbmd0aCA9PSAxICYmXG4gICAgICAgIG9wdGlvbnNBcnJheS5pbmRleE9mKE9iamVjdC5rZXlzKG9wdHMpWzBdKSAhPSAtMSAmJiB0eXBlb2Ygb3B0c1tPYmplY3Qua2V5cyhvcHRzKVswXV0gIT0gJ3N0cmluZycgJiYgXG4gICAgICAgIG9wdGlvbnNFcnIoJ2xpc3RFcnJvcjogT3B0aW9ucyB2YWx1ZSB0eXBlIHNob3VsZCBiZSBhIHN0cmluZycpXG5cbiAgICAgICAgLy8gQ29udGFpbmVyIHRoYXQgd2lsbCBiZSB1c2UgdG8gYmUgbXV0YXRlZCBsYXRlciwgdXNlZCB0byBmb3IgcmV0dXJuIG9mIHRoZSBkYXRhXG4gICAgICAgIGxldCByZXMgPSB1bmRlZmluZWRcblxuICAgICAgICAvLyByZXR1cm5lZCBtZXRob2RzXG4gICAgICAgIGxldCBtZXRob2RzID0ge31cblxuICAgICAgICAvLyBtb2RlcyBcbiAgICAgICAgY29uc3QgbW9kZXMgPSBbJ2FzYycsJ2RlYyddXG5cbiAgICAgICAgLy8gVXNlRGF0YVxuICAgICAgICBsZXQgVXNlckRhdGEgPSB1bmRlZmluZWRcbiAgICAgICAgb2JqRmlyc3RBcmcgICAgICYmIChVc2VyRGF0YSA9IHtwYXRoOiBsaWIucm9vdFBhdGgsIG9wdGlvbnM6YWJzb2x1dGVQYXRofSlcbiAgICAgICAgLy8gc3RyaW5nRmlyc3RBcmcgICYmIChVc2VyRGF0YSA9IHtwYXRoOiBhYnNvbHV0ZVBhdGguZW5kc1dpdGgoJy8nKSA/IGFic29sdXRlUGF0aCA6IGAke2Fic29sdXRlUGF0aH0vYCwgb3B0aW9uczp1bmRlZmluZWR9KVxuXG4gICAgICAgIC8vIHdoYXQgaWYgY2QgbGluayBoYXMgdGhlIHNhbWUgbGluayBhcyBscyA/IFxuICAgICAgICBjb25zdCBzdHJGaXJzdEFyZ0MxID0gdHlwZW9mIGxpYi5yb290UGF0aCA9PSAnc3RyaW5nJyAmJiB0eXBlb2YgYWJzb2x1dGVQYXRoID09ICdzdHJpbmcnXG4gICAgICAgIGNvbnN0IHN0ckZpcnN0QXJnQzIgPSBzdHJGaXJzdEFyZ0MxICYmIGxpYi5yb290UGF0aCA9PSBhYnNvbHV0ZVBhdGggPyB0cnVlIDogZmFsc2VcbiAgICAgICAgY29uc3Qgc3RyRmlyc3RBcmdDMyA9IHN0ckZpcnN0QXJnQzIgPyBhYnNvbHV0ZVBhdGggOiBgJHtsaWIucm9vdFBhdGggPT0gdW5kZWZpbmVkID8gJycgOiBsaWIucm9vdFBhdGh9JHthYnNvbHV0ZVBhdGh9YFxuXG4gICAgICAgIC8vIGFzc2lnbiBjb3JyZWN0IGRhdGFcbiAgICAgICAgc3RyaW5nRmlyc3RBcmcgICYmIChVc2VyRGF0YSA9IHtwYXRoOiBzdHJGaXJzdEFyZ0MzLmVuZHNXaXRoKCcvJykgPyBzdHJGaXJzdEFyZ0MzIDogYCR7c3RyRmlyc3RBcmdDM30vYCwgb3B0aW9uczp1bmRlZmluZWR9KVxuICAgICAgICBjb21wbGV0ZUFyZ3MgICAgJiYgKFVzZXJEYXRhID0ge3BhdGg6IHN0ckZpcnN0QXJnQzMuZW5kc1dpdGgoJy8nKSA/IHN0ckZpcnN0QXJnQzMgOiBgJHtzdHJGaXJzdEFyZ0MzfS9gLCBvcHRpb25zfSlcbiAgICAgICAgYWxsVW5kZWYgICAgICAgICYmIChVc2VyRGF0YSA9IHtwYXRoOiBsaWIucm9vdFBhdGgsIG9wdGlvbnM6b3B0aW9uc30pXG5cbiAgICAgICAgLy8gQ29udGVudHNcbiAgICAgICAgbGV0IGNvbnRlbnRzID0gW11cbiAgICAgICAgY29uc3QgZG9lc1BhdGhFeGlzdCA9IGZzLmV4aXN0c1N5bmMoVXNlckRhdGEucGF0aClcbiAgICAgICAgaWYoIWRvZXNQYXRoRXhpc3Qpe3Rocm93IG5ldyBQYXRoRG9lc05vdEV4aXN0RXJyb3IoYG9uIGxzOiBubyBzdWNoIGRpcmVjdG9yeSAke1VzZXJEYXRhLnBhdGh9YCl9XG4gICAgICAgIGRvZXNQYXRoRXhpc3QgJiYgc2V0QyhVc2VyRGF0YS5wYXRoKVxuXG4gICAgICAgIHJldHVybiBjZFxuICAgIH1cblxuICAgIC8vXG4gICAgbGliLnRvdWNoID0gKGZpbGUpID0+IHtcbiAgICAgICAgLy8gc2FuaXRpemluZ1xuICAgICAgICBmaWxlID09IHVuZGVmaW5lZCAmJiBlcnIoJ2Vycm9yIHRvdWNoOiB0b3VjaCBwYXJhbWV0ZXIgY2Fubm90IGJlIHVuZGVmaW5lZCcpXG4gICAgICAgIHR5cGVvZiBmaWxlICE9ICdzdHJpbmcnICYmIGZpbGVbMF0gPT0gdW5kZWZpbmVkICYmIGVycignZXJyb3IgdG91Y2g6IGludmFsaWQgdHB5ZSBpbiBwYXJhbWV0ZXIgc2hvdWxkIGJlIGEgc3RyaW5nIG9yIGFycmF5JylcblxuXG4gICAgICAgIGNvbnN0IGMxID0gKCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgb3JpZ2luUGF0aCA9IE9iamVjdC5rZXlzKCBxdWVyeVN0cmluZy5wYXJzZShmaWxlLCcvJykgKVxuICAgICAgICAgICAgY29uc3QgcGF0aExlbiA9IG9yaWdpblBhdGgubGVuZ3RoIC0gMVxuICAgICAgICAgICAgY29uc3QgcGF0aEZpbGUgPSBgLyR7b3JpZ2luUGF0aC5zcGxpY2UocGF0aExlbiwxKVswXX1gXG4gICAgICAgICAgICBvcmlnaW5QYXRoLnNwbGljZShwYXRoTGVuLDEpXG4gICAgICAgICAgICBsZXQgbmV3UGF0aCA9ICcnXG4gICAgICAgICAgICBvcmlnaW5QYXRoLm1hcChlID0+IG5ld1BhdGggKz0gYC8ke2V9YClcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgZnMuZXhpc3RzU3luYyhuZXdQYXRoKSA/IFxuICAgICAgICAgICAgICAgIGZzLmV4aXN0c1N5bmMoYCR7bmV3UGF0aH0ke3BhdGhGaWxlfWApID8gZXJyKGAke3BhdGhGaWxlfSBhbHJlYWR5IGV4aXN0IGluICR7bmV3UGF0aH0gZGlyZWN0b3J5YCkgOiBcbiAgICAgICAgICAgICAgICBmcy53cml0ZUZpbGVTeW5jKGAke25ld1BhdGh9JHtwYXRoRmlsZX1gKVxuICAgICAgICAgICAgOiAgZXJyKGB0aGVyZSBpcyBubyBzdWNoIGRpcmVjdG9yeSAke25ld1BhdGh9YClcblxuICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfVxuXG4gICAgICAgIGxpYi5yb290UGF0aCA9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGZpbGUgPT0gJ3N0cmluZycgJiYgYzEoKVxuICAgICAgICBcbiAgICAgICAgLy8gY29uc29sZS5sb2coYCR7ZmlsZX0gLS0+ICR7bGliLnJvb3RQYXRofWApXG4gICAgICAgIFxuICAgICAgICAvLyBjaGVja2luZyBleGlzdGFuY2NlXG4gICAgICAgIFxuICAgIH1cblxuICAgIC8vIGMuIG1rZGlyIGNyZWF0ZXMgbmV3IGRpcmVjdG9yeVxuICAgIC8vIGMuY2FzZXMgOiBta2RpcihbXSkgLS0+IGFjY2VwdHMgYXJyYXkgYXMgYW4gYXJ1Z3VtZW50IGFzIGZvbGRlciBuYW1lcyB8IG1hc3MgZm9sZGVyIGNyZWF0aW9uXG4gICAgLy8gYy5jYXNlcyA6IG1rZGlyKCcnKSAtLT4gYWNjZXB0cyBzdHJpbmcgfCBzaW5nbGUgZGlyIGNyZWF0aW9uXG4gICAgbGliLm1rZGlyID0gKHBhdGgpID0+IHtcblxuICAgIH1cblxuICAgIGRlbGV0ZSBsaWIucm9vdFBhdGhcbiAgICByZXR1cm4gbGliXG59KSgpXG5cbm1vZHVsZS5leHBvcnRzID0gZCJdfQ==