64bca2d7f54778aab9d4ee7055351703
"use strict";

const fs = require('fs');
const queryString = require('querystring');
const d = (() => {
    // Current Data set 
    const dir = {
        name: undefined,
        publicPath: undefined,
        parentDir: undefined,
        label: undefined,
        items: undefined,
        size: undefined,
        type: undefined, // directory or file
        fileAccess: undefined,
        birttime: undefined
        // init empty lib
    };let lib = {};
    let cd = undefined;
    lib.rootPath = undefined;
    // Utils
    function ArgsParamTypeError(message) {
        this.message = message;
    }
    function PathDoesNotExistError(message) {
        this.message = message;
    }
    function ERROR(message) {
        this.message = message;
    }
    function err(message) {
        throw new ERROR(message);
    }
    function isUndef(val, fnName) {
        let y = [];
        val.forEach(el => {
            y.push(el == undefined);
        });
        if (y.indexOf(true) != -1) {
            throw {
                message: `${fnName} function arg position ${y.indexOf(true)} cannot be undefined`
            };
        }
    }
    function isType(types, fnName, t) {
        isUndef([types, fnName, t], fnName);

        if (types.indexOf(false) == -1) {
            return true;
        } else {
            throw new ArgsParamTypeError(`on ${fnName}() function argument position (${types.indexOf(false) + 1}) cannot be undefined should be a ${t[types.indexOf(false)]}`);
        }
    }
    function isEmpty(val, fn) {
        if (val == '') {
            throw {
                message: `${fn} function cannot take an empty string as an argument`
            };
        }
    }
    function getSize(path) {
        let totalSize = 0;

        // recursion
        const recur = path => {
            let isThereADir = [];
            fs.lstatSync(path).isDirectory() ? isThereADir = fs.readdirSync(path) : totalSize += fs.lstatSync(path).size;
            isThereADir.length != 0 && isThereADir.map(e => recur(`${path}/${e}`));
        };

        // initial call
        recur(path);

        return totalSize;
    }
    function getChildPaths(path) {
        let children = {
            dir: [],
            files: []
        };
        const isD = fs.statSync(path).isDirectory() ? true : false;
        const items = isD ? fs.readdirSync(path) : path;
        typeof items == 'object' ? items.map(e => children.dir.push(`${path}${e}`)) : children.files.push(items);
        return children;
    }
    function setC(T) {
        let newA = [];
        cd = fs.readdirSync(T);
        cd.forEach(child => {
            const G = Object.create(dir);
            G.name = child;
            G.publicPath = `${T}${child}`;
            G.parentDir = T;
            G.label = 'none';
            G.items = fs.lstatSync(`${T}${child}`).isDirectory() ? G.items = fs.readdirSync(`${T}${child}`).length : G.items = 'none';
            G.size = getSize(`${T}${child}`);
            G.birthtime = fs.lstatSync(T).birthtime;
            G.type = fs.lstatSync(`${T}/${child}`).isDirectory() ? 'folder/directory' : 'file/application';
            G.children = getChildPaths(`${T}${child}`).length == 0 ? 'none' : getChildPaths(`${T}${child}`);
            G.fileAccess = 'rw+';
            if (fs.lstatSync(`${T}${child}`).isDirectory()) {
                delete G.fileAccess;
                G.folderAccess = 'rw+';
            } else {
                delete G.items;
                G.fileAccess = 'rw+';
            }
            newA.push(G);
        });
        cd = newA;
    }
    const Layer = function (data, { beforeEnter, hasEntered, onExit }) {
        const bE = beforeEnter(data);
        const oE = hasEntered(bE);
        onExit(oE);
    };
    // libs

    // a. set rooth path directory
    lib.cd = path => {
        isType([[typeof path] == 'string'], 'cd', ['string']);
        isEmpty(path, 'cd');

        const sanitizedPath = path.endsWith('/') ? path : `${path}/`;

        if (fs.existsSync(sanitizedPath)) {
            lib.rootPath = sanitizedPath;
            setC(sanitizedPath);
        } else {
            throw {
                message: `cd: no such directory ${sanitizedPath}`
            };
        }
        return true;
    };

    // b. retunrs an array of properties, of folder contents
    lib.ls = (absolutePath, options) => {
        // case 1, absolutepath is object, so the path that well be used
        //         to travers the directory is the cd path,
        //         it is expected that the object has object keys for options array
        const objFirstArg = typeof absolutePath == 'object' && options == undefined && absolutePath;

        // case 2, absolutepath is string, it means the user provided an absolute path
        //         which means the cd path if it is being set will be ignored
        const stringFirstArg = typeof absolutePath == 'string' && options == undefined && true;

        // case 3, 
        const completeArgs = typeof absolutePath == 'string' && typeof options == 'object';

        // case 4
        const allUndef = absolutePath == undefined && options == undefined;

        // options error
        const optionsErr = err => {
            throw { message: err };
        };

        // switch base on what case the user take
        const opts = objFirstArg ? objFirstArg : options;
        const opts2 = stringFirstArg ? absolutePath : opts;
        const opts3 = completeArgs ? options : opts2;
        const opts4 = allUndef && lib.rootPath;
        const optsRes = opts4 ? opts4 : opts3;

        // toggle types
        let currentType = 'object';
        const changeType = type => currentType = type;
        stringFirstArg && changeType('string');
        completeArgs && changeType('object');
        allUndef && changeType('string');

        // This the only available options, this is the keys that the user will provide
        const optionsArray = ['endsWith', 'startsWith', 'wildCard'];
        Object.seal(optionsArray);

        // rootPath is not set and absolutePath is not
        lib.rootPath == undefined && absolutePath == undefined && optionsErr(`ls: Path cannot be undefined, at least set a roothPath`);

        // if option is not a type of object throw an error | ls()
        typeof optsRes != currentType && optionsErr(`ls: Options should be a type of ${currentType} only`);

        // if options object is empty throw an error | ls({})
        typeof opts == currentType && Object.keys(opts).length == 0 && optionsErr(`listError: Options ${currentType} cannot be empty`);

        // if options object has more than one key throw an error
        typeof opts == currentType && Object.keys(opts).length != 1 && optionsErr('listError: Options object cannot be more than one');

        // typo in the options key
        typeof opts == currentType && Object.keys(opts).length == 1 && optionsArray.indexOf(Object.keys(opts)[0]) == -1 && optionsErr(`listError: "${Object.keys(opts)[0]}" is not recognized, options are "${optionsArray}"`);

        // empty value
        typeof opts == currentType && Object.keys(opts).length == 1 && optionsArray.indexOf(Object.keys(opts)[0]) != -1 && opts[Object.keys(opts)[0]] == '' && optionsErr('listError: Options value cannot be an empty string');

        // not a string value
        typeof opts == 'object' && Object.keys(opts).length == 1 && optionsArray.indexOf(Object.keys(opts)[0]) != -1 && typeof opts[Object.keys(opts)[0]] != 'string' && optionsErr('listError: Options value type should be a string');

        // Container that will be use to be mutated later, used to for return of the data
        let res = undefined;

        // returned methods
        let methods = {};

        // modes 
        const modes = ['asc', 'dec'];

        // UseData
        let UserData = undefined;
        objFirstArg && (UserData = { path: lib.rootPath, options: absolutePath });
        // stringFirstArg  && (UserData = {path: absolutePath.endsWith('/') ? absolutePath : `${absolutePath}/`, options:undefined})

        // what if cd link has the same link as ls ? 
        const strFirstArgC1 = typeof lib.rootPath == 'string' && typeof absolutePath == 'string';
        const strFirstArgC2 = strFirstArgC1 && lib.rootPath == absolutePath ? true : false;
        const strFirstArgC3 = strFirstArgC2 ? absolutePath : `${lib.rootPath == undefined ? '' : lib.rootPath}${absolutePath}`;

        // assign correct data
        stringFirstArg && (UserData = { path: strFirstArgC3.endsWith('/') ? strFirstArgC3 : `${strFirstArgC3}/`, options: undefined });
        completeArgs && (UserData = { path: strFirstArgC3.endsWith('/') ? strFirstArgC3 : `${strFirstArgC3}/`, options });
        allUndef && (UserData = { path: lib.rootPath, options: options });

        // Contents
        let contents = [];
        const doesPathExist = fs.existsSync(UserData.path);
        if (!doesPathExist) {
            throw new PathDoesNotExistError(`on ls: no such directory ${UserData.path}`);
        }
        doesPathExist && setC(UserData.path);

        return cd;
    };

    //
    lib.touch = file => {
        // sanitizing
        file == undefined && err('error touch: touch parameter cannot be undefined');
        typeof file != 'string' && file[0] == undefined && err('error touch: invalid tpye in parameter should be a string or array');

        const c1 = () => {
            const originPath = Object.keys(queryString.parse(file, '/'));
            const pathLen = originPath.length - 1;
            const pathFile = `/${originPath.splice(pathLen, 1)[0]}`;
            originPath.splice(pathLen, 1);
            let newPath = '';
            originPath.map(e => newPath += `/${e}`);

            !fs.existsSync(newPath) ? err(`there is no such directory ${newPath}`) : fs.writeFileSync(`${newPath}${pathFile}`);
            console.log(`${newPath}${pathFile}`);
        };

        c1();

        // console.log(`${file} --> ${lib.rootPath}`)

        // checking existancce
    };

    // c. mkdir creates new directory
    // c.cases : mkdir([]) --> accepts array as an arugument as folder names | mass folder creation
    // c.cases : mkdir('') --> accepts string | single dir creation
    lib.mkdir = path => {};

    delete lib.rootPath;
    return lib;
})();

module.exports = d;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYl9kcWZzLmpzIl0sIm5hbWVzIjpbImZzIiwicmVxdWlyZSIsInF1ZXJ5U3RyaW5nIiwiZCIsImRpciIsIm5hbWUiLCJ1bmRlZmluZWQiLCJwdWJsaWNQYXRoIiwicGFyZW50RGlyIiwibGFiZWwiLCJpdGVtcyIsInNpemUiLCJ0eXBlIiwiZmlsZUFjY2VzcyIsImJpcnR0aW1lIiwibGliIiwiY2QiLCJyb290UGF0aCIsIkFyZ3NQYXJhbVR5cGVFcnJvciIsIm1lc3NhZ2UiLCJQYXRoRG9lc05vdEV4aXN0RXJyb3IiLCJFUlJPUiIsImVyciIsImlzVW5kZWYiLCJ2YWwiLCJmbk5hbWUiLCJ5IiwiZm9yRWFjaCIsImVsIiwicHVzaCIsImluZGV4T2YiLCJpc1R5cGUiLCJ0eXBlcyIsInQiLCJpc0VtcHR5IiwiZm4iLCJnZXRTaXplIiwicGF0aCIsInRvdGFsU2l6ZSIsInJlY3VyIiwiaXNUaGVyZUFEaXIiLCJsc3RhdFN5bmMiLCJpc0RpcmVjdG9yeSIsInJlYWRkaXJTeW5jIiwibGVuZ3RoIiwibWFwIiwiZSIsImdldENoaWxkUGF0aHMiLCJjaGlsZHJlbiIsImZpbGVzIiwiaXNEIiwic3RhdFN5bmMiLCJzZXRDIiwiVCIsIm5ld0EiLCJjaGlsZCIsIkciLCJPYmplY3QiLCJjcmVhdGUiLCJiaXJ0aHRpbWUiLCJmb2xkZXJBY2Nlc3MiLCJMYXllciIsImRhdGEiLCJiZWZvcmVFbnRlciIsImhhc0VudGVyZWQiLCJvbkV4aXQiLCJiRSIsIm9FIiwic2FuaXRpemVkUGF0aCIsImVuZHNXaXRoIiwiZXhpc3RzU3luYyIsImxzIiwiYWJzb2x1dGVQYXRoIiwib3B0aW9ucyIsIm9iakZpcnN0QXJnIiwic3RyaW5nRmlyc3RBcmciLCJjb21wbGV0ZUFyZ3MiLCJhbGxVbmRlZiIsIm9wdGlvbnNFcnIiLCJvcHRzIiwib3B0czIiLCJvcHRzMyIsIm9wdHM0Iiwib3B0c1JlcyIsImN1cnJlbnRUeXBlIiwiY2hhbmdlVHlwZSIsIm9wdGlvbnNBcnJheSIsInNlYWwiLCJrZXlzIiwicmVzIiwibWV0aG9kcyIsIm1vZGVzIiwiVXNlckRhdGEiLCJzdHJGaXJzdEFyZ0MxIiwic3RyRmlyc3RBcmdDMiIsInN0ckZpcnN0QXJnQzMiLCJjb250ZW50cyIsImRvZXNQYXRoRXhpc3QiLCJ0b3VjaCIsImZpbGUiLCJjMSIsIm9yaWdpblBhdGgiLCJwYXJzZSIsInBhdGhMZW4iLCJwYXRoRmlsZSIsInNwbGljZSIsIm5ld1BhdGgiLCJ3cml0ZUZpbGVTeW5jIiwiY29uc29sZSIsImxvZyIsIm1rZGlyIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUEsTUFBTUEsS0FBS0MsUUFBUSxJQUFSLENBQVg7QUFDQSxNQUFNQyxjQUFjRCxRQUFRLGFBQVIsQ0FBcEI7QUFDQSxNQUFNRSxJQUFJLENBQUMsTUFBTTtBQUNqQjtBQUNJLFVBQU1DLE1BQU07QUFDUkMsY0FBTUMsU0FERTtBQUVSQyxvQkFBWUQsU0FGSjtBQUdSRSxtQkFBV0YsU0FISDtBQUlSRyxlQUFPSCxTQUpDO0FBS1JJLGVBQU9KLFNBTEM7QUFNUkssY0FBTUwsU0FORTtBQU9STSxjQUFNTixTQVBFLEVBT1M7QUFDakJPLG9CQUFZUCxTQVJKO0FBU1JRLGtCQUFVUjtBQUVsQjtBQVhnQixLQUFaLENBWUEsSUFBSVMsTUFBTSxFQUFWO0FBQ0EsUUFBSUMsS0FBS1YsU0FBVDtBQUNBUyxRQUFJRSxRQUFKLEdBQWVYLFNBQWY7QUFDSjtBQUNJLGFBQVNZLGtCQUFULENBQTRCQyxPQUE1QixFQUFxQztBQUNqQyxhQUFLQSxPQUFMLEdBQWVBLE9BQWY7QUFDSDtBQUNELGFBQVNDLHFCQUFULENBQStCRCxPQUEvQixFQUF3QztBQUNwQyxhQUFLQSxPQUFMLEdBQWVBLE9BQWY7QUFDSDtBQUNELGFBQVNFLEtBQVQsQ0FBZUYsT0FBZixFQUF1QjtBQUNuQixhQUFLQSxPQUFMLEdBQWVBLE9BQWY7QUFDSDtBQUNELGFBQVNHLEdBQVQsQ0FBYUgsT0FBYixFQUFzQjtBQUNsQixjQUFNLElBQUlFLEtBQUos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QTFDLENBQTFCLEdBQXlFMUcsR0FBRzJHLGFBQUgsQ0FBa0IsR0FBRUQsT0FBUSxHQUFFRixRQUFTLEVBQXZDLENBQXpFO0FBQ0FJLG9CQUFRQyxHQUFSLENBQWEsR0FBRUgsT0FBUSxHQUFFRixRQUFTLEVBQWxDO0FBQ0gsU0FWRDs7QUFZQUo7O0FBRUE7O0FBRUE7QUFFSCxLQXhCRDs7QUEwQkE7QUFDQTtBQUNBO0FBQ0FyRixRQUFJK0YsS0FBSixHQUFhekUsSUFBRCxJQUFVLENBRXJCLENBRkQ7O0FBSUEsV0FBT3RCLElBQUlFLFFBQVg7QUFDQSxXQUFPRixHQUFQO0FBQ0gsQ0E5UVMsR0FBVjs7QUFnUkFnRyxPQUFPQyxPQUFQLEdBQWlCN0csQ0FBakIiLCJmaWxlIjoibGliX2RxZnMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIlxuXG5jb25zdCBmcyA9IHJlcXVpcmUoJ2ZzJylcbmNvbnN0IHF1ZXJ5U3RyaW5nID0gcmVxdWlyZSgncXVlcnlzdHJpbmcnKVxuY29uc3QgZCA9ICgoKSA9PiB7XG4vLyBDdXJyZW50IERhdGEgc2V0IFxuICAgIGNvbnN0IGRpciA9IHtcbiAgICAgICAgbmFtZTogdW5kZWZpbmVkLFxuICAgICAgICBwdWJsaWNQYXRoOiB1bmRlZmluZWQsXG4gICAgICAgIHBhcmVudERpcjogdW5kZWZpbmVkLFxuICAgICAgICBsYWJlbDogdW5kZWZpbmVkLFxuICAgICAgICBpdGVtczogdW5kZWZpbmVkLFxuICAgICAgICBzaXplOiB1bmRlZmluZWQsXG4gICAgICAgIHR5cGU6IHVuZGVmaW5lZCwgLy8gZGlyZWN0b3J5IG9yIGZpbGVcbiAgICAgICAgZmlsZUFjY2VzczogdW5kZWZpbmVkLFxuICAgICAgICBiaXJ0dGltZTogdW5kZWZpbmVkLFxuICAgIH1cbi8vIGluaXQgZW1wdHkgbGliXG4gICAgbGV0IGxpYiA9IHt9XG4gICAgbGV0IGNkID0gdW5kZWZpbmVkXG4gICAgbGliLnJvb3RQYXRoID0gdW5kZWZpbmVkXG4vLyBVdGlsc1xuICAgIGZ1bmN0aW9uIEFyZ3NQYXJhbVR5cGVFcnJvcihtZXNzYWdlKSB7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2VcbiAgICB9XG4gICAgZnVuY3Rpb24gUGF0aERvZXNOb3RFeGlzdEVycm9yKG1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZVxuICAgIH1cbiAgICBmdW5jdGlvbiBFUlJPUihtZXNzYWdlKXtcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZVxuICAgIH1cbiAgICBmdW5jdGlvbiBlcnIobWVzc2FnZSkge1xuICAgICAgICB0aHJvdyBuZXcgRVJST1IobWVzc2FnZSlcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNVbmRlZih2YWwsZm5OYW1lKXtcbiAgICAgICAgbGV0IHkgPSBbXVxuICAgICAgICB2YWwuZm9yRWFjaChlbCA9PiB7XG4gICAgICAgICAgICB5LnB1c2goZWwgPT0gdW5kZWZpbmVkKVxuICAgICAgICB9KVxuICAgICAgICBpZih5LmluZGV4T2YodHJ1ZSkgIT0gLTEpe1xuICAgICAgICAgICAgdGhyb3d7XG4gICAgICAgICAgICAgICAgbWVzc2FnZTogYCR7Zm5OYW1lfSBmdW5jdGlvbiBhcmcgcG9zaXRpb24gJHt5LmluZGV4T2YodHJ1ZSl9IGNhbm5vdCBiZSB1bmRlZmluZWRgXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gaXNUeXBlKHR5cGVzLGZuTmFtZSx0KXtcbiAgICAgICAgaXNVbmRlZihbdHlwZXMsZm5OYW1lLHRdLGZuTmFtZSlcblxuICAgICAgICBpZih0eXBlcy5pbmRleE9mKGZhbHNlKSA9PSAtMSl7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcmdzUGFyYW1UeXBlRXJyb3IoXG4gICAgICAgICAgICAgICAgYG9uICR7Zm5OYW1lfSgpIGZ1bmN0aW9uIGFyZ3VtZW50IHBvc2l0aW9uICgke3R5cGVzLmluZGV4T2YoZmFsc2UpICsgMX0pIGNhbm5vdCBiZSB1bmRlZmluZWQgc2hvdWxkIGJlIGEgJHt0W3R5cGVzLmluZGV4T2YoZmFsc2UpXX1gXG4gICAgICAgICAgICApXG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gaXNFbXB0eSh2YWwsZm4pe1xuICAgICAgICBpZih2YWwgPT0gJycpe1xuICAgICAgICAgICAgdGhyb3cge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGAke2ZufSBmdW5jdGlvbiBjYW5ub3QgdGFrZSBhbiBlbXB0eSBzdHJpbmcgYXMgYW4gYXJndW1lbnRgXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0U2l6ZShwYXRoKXtcbiAgICAgICAgbGV0IHRvdGFsU2l6ZSAgPSAwICAgXG5cbiAgICAgICAgLy8gcmVjdXJzaW9uXG4gICAgICAgIGNvbnN0IHJlY3VyID0gcGF0aCA9PiB7XG4gICAgICAgICAgICBsZXQgaXNUaGVyZUFEaXIgPSBbXVxuICAgICAgICAgICAgZnMubHN0YXRTeW5jKHBhdGgpLmlzRGlyZWN0b3J5KCkgPyAoaXNUaGVyZUFEaXIgPSBmcy5yZWFkZGlyU3luYyhwYXRoKSkgOiB0b3RhbFNpemUgKz0gZnMubHN0YXRTeW5jKHBhdGgpLnNpemVcbiAgICAgICAgICAgIGlzVGhlcmVBRGlyLmxlbmd0aCAhPSAwICYmIGlzVGhlcmVBRGlyLm1hcChlID0+IHJlY3VyKGAke3BhdGh9LyR7ZX1gKSlcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gaW5pdGlhbCBjYWxsXG4gICAgICAgIHJlY3VyKHBhdGgpXG4gICAgICAgIFxuICAgICAgICByZXR1cm4gdG90YWxTaXplXG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldENoaWxkUGF0aHMocGF0aCl7XG4gICAgICAgIGxldCBjaGlsZHJlbiA9IHtcbiAgICAgICAgICAgIGRpcjogW10sXG4gICAgICAgICAgICBmaWxlczogW11cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpc0QgPSBmcy5zdGF0U3luYyhwYXRoKS5pc0RpcmVjdG9yeSgpID8gdHJ1ZSA6IGZhbHNlXG4gICAgICAgIGNvbnN0IGl0ZW1zID0gaXNEID8gZnMucmVhZGRpclN5bmMocGF0aCkgOiBwYXRoICAgICAgICBcbiAgICAgICAgdHlwZW9mIGl0ZW1zID09ICdvYmplY3QnID8gaXRlbXMubWFwKGUgPT4gY2hpbGRyZW4uZGlyLnB1c2goYCR7cGF0aH0ke2V9YCkpIDogY2hpbGRyZW4uZmlsZXMucHVzaChpdGVtcylcbiAgICAgICAgcmV0dXJuIGNoaWxkcmVuXG4gICAgfVxuICAgIGZ1bmN0aW9uIHNldEMoVCl7XG4gICAgICAgIGxldCBuZXdBID0gW11cbiAgICAgICAgY2QgPSBmcy5yZWFkZGlyU3luYyhUKVxuICAgICAgICBjZC5mb3JFYWNoKGNoaWxkID0+IHtcbiAgICAgICAgICAgIGNvbnN0IEcgPSBPYmplY3QuY3JlYXRlKGRpcilcbiAgICAgICAgICAgIEcubmFtZSA9IGNoaWxkXG4gICAgICAgICAgICBHLnB1YmxpY1BhdGggPSBgJHtUfSR7Y2hpbGR9YFxuICAgICAgICAgICAgRy5wYXJlbnREaXIgPSBUXG4gICAgICAgICAgICBHLmxhYmVsID0gJ25vbmUnXG4gICAgICAgICAgICBHLml0ZW1zID0gZnMubHN0YXRTeW5jKGAke1R9JHtjaGlsZH1gKS5pc0RpcmVjdG9yeSgpID8gRy5pdGVtcyA9IGZzLnJlYWRkaXJTeW5jKGAke1R9JHtjaGlsZH1gKS5sZW5ndGggOiBHLml0ZW1zID0gJ25vbmUnXG4gICAgICAgICAgICBHLnNpemUgPSBnZXRTaXplKGAke1R9JHtjaGlsZH1gKVxuICAgICAgICAgICAgRy5iaXJ0aHRpbWUgPSBmcy5sc3RhdFN5bmMoVCkuYmlydGh0aW1lXG4gICAgICAgICAgICBHLnR5cGUgPSBmcy5sc3RhdFN5bmMoYCR7VH0vJHtjaGlsZH1gKS5pc0RpcmVjdG9yeSgpID8gJ2ZvbGRlci9kaXJlY3RvcnknIDogJ2ZpbGUvYXBwbGljYXRpb24nXG4gICAgICAgICAgICBHLmNoaWxkcmVuID0gZ2V0Q2hpbGRQYXRocyhgJHtUfSR7Y2hpbGR9YCkubGVuZ3RoID09IDAgPyAnbm9uZScgOiBnZXRDaGlsZFBhdGhzKGAke1R9JHtjaGlsZH1gKVxuICAgICAgICAgICAgRy5maWxlQWNjZXNzID0gJ3J3KydcbiAgICAgICAgICAgIGlmKGZzLmxzdGF0U3luYyggYCR7VH0ke2NoaWxkfWAgKS5pc0RpcmVjdG9yeSgpICl7XG4gICAgICAgICAgICAgICAgZGVsZXRlIEcuZmlsZUFjY2Vzc1xuICAgICAgICAgICAgICAgIEcuZm9sZGVyQWNjZXNzID0gJ3J3KydcbiAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBHLml0ZW1zXG4gICAgICAgICAgICAgICAgRy5maWxlQWNjZXNzID0gJ3J3KydcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5ld0EucHVzaChHKVxuICAgICAgICB9KVxuICAgICAgICBjZCA9IG5ld0FcbiAgICB9XG4gICAgY29uc3QgTGF5ZXIgPSBmdW5jdGlvbihkYXRhLHtiZWZvcmVFbnRlcixoYXNFbnRlcmVkLG9uRXhpdH0pIHtcbiAgICAgICAgY29uc3QgYkUgPSBiZWZvcmVFbnRlcihkYXRhKVxuICAgICAgICBjb25zdCBvRSA9IGhhc0VudGVyZWQoYkUpXG4gICAgICAgIG9uRXhpdChvRSlcbiAgICB9XG4vLyBsaWJzXG4gICAgXG4gICAgLy8gYS4gc2V0IHJvb3RoIHBhdGggZGlyZWN0b3J5XG4gICAgbGliLmNkID0gKHBhdGgpID0+IHsgICAgICAgIFxuICAgICAgICBpc1R5cGUoW1xuICAgICAgICAgICAgW3R5cGVvZiBwYXRoXSA9PSAnc3RyaW5nJ1xuICAgICAgICBdLCdjZCcsWydzdHJpbmcnXSlcbiAgICAgICAgaXNFbXB0eShwYXRoLCdjZCcpXG4gICAgICAgIFxuICAgICAgICBjb25zdCBzYW5pdGl6ZWRQYXRoID0gcGF0aC5lbmRzV2l0aCgnLycpID8gcGF0aCA6IGAke3BhdGh9L2BcbiAgICAgICAgXG4gICAgICAgIGlmKGZzLmV4aXN0c1N5bmMoc2FuaXRpemVkUGF0aCkpeyAgICAgICAgICAgIFxuICAgICAgICAgICAgbGliLnJvb3RQYXRoID0gc2FuaXRpemVkUGF0aFxuICAgICAgICAgICAgc2V0QyhzYW5pdGl6ZWRQYXRoKVxuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgIHRocm93e1xuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGBjZDogbm8gc3VjaCBkaXJlY3RvcnkgJHtzYW5pdGl6ZWRQYXRofWBcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSAgICAgICAgXG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIFxuICAgIC8vIGIuIHJldHVucnMgYW4gYXJyYXkgb2YgcHJvcGVydGllcywgb2YgZm9sZGVyIGNvbnRlbnRzXG4gICAgbGliLmxzID0gKGFic29sdXRlUGF0aCxvcHRpb25zKSA9PiB7XG4gICAgICAgIC8vIGNhc2UgMSwgYWJzb2x1dGVwYXRoIGlzIG9iamVjdCwgc28gdGhlIHBhdGggdGhhdCB3ZWxsIGJlIHVzZWRcbiAgICAgICAgLy8gICAgICAgICB0byB0cmF2ZXJzIHRoZSBkaXJlY3RvcnkgaXMgdGhlIGNkIHBhdGgsXG4gICAgICAgIC8vICAgICAgICAgaXQgaXMgZXhwZWN0ZWQgdGhhdCB0aGUgb2JqZWN0IGhhcyBvYmplY3Qga2V5cyBmb3Igb3B0aW9ucyBhcnJheVxuICAgICAgICBjb25zdCBvYmpGaXJzdEFyZyA9IHR5cGVvZiBhYnNvbHV0ZVBhdGggPT0gJ29iamVjdCcgJiYgb3B0aW9ucyA9PSB1bmRlZmluZWQgJiYgYWJzb2x1dGVQYXRoXG5cbiAgICAgICAgLy8gY2FzZSAyLCBhYnNvbHV0ZXBhdGggaXMgc3RyaW5nLCBpdCBtZWFucyB0aGUgdXNlciBwcm92aWRlZCBhbiBhYnNvbHV0ZSBwYXRoXG4gICAgICAgIC8vICAgICAgICAgd2hpY2ggbWVhbnMgdGhlIGNkIHBhdGggaWYgaXQgaXMgYmVpbmcgc2V0IHdpbGwgYmUgaWdub3JlZFxuICAgICAgICBjb25zdCBzdHJpbmdGaXJzdEFyZyA9IHR5cGVvZiBhYnNvbHV0ZVBhdGggPT0gJ3N0cmluZycgJiYgb3B0aW9ucyA9PSB1bmRlZmluZWQgJiYgdHJ1ZVxuXG4gICAgICAgIC8vIGNhc2UgMywgXG4gICAgICAgIGNvbnN0IGNvbXBsZXRlQXJncyA9IHR5cGVvZiBhYnNvbHV0ZVBhdGggPT0gJ3N0cmluZycgJiYgdHlwZW9mIG9wdGlvbnMgPT0gJ29iamVjdCdcblxuICAgICAgICAvLyBjYXNlIDRcbiAgICAgICAgY29uc3QgYWxsVW5kZWYgPSBhYnNvbHV0ZVBhdGggPT0gdW5kZWZpbmVkICYmIG9wdGlvbnMgPT0gdW5kZWZpbmVkXG5cbiAgICAgICAgLy8gb3B0aW9ucyBlcnJvclxuICAgICAgICBjb25zdCBvcHRpb25zRXJyID0gKGVycikgPT4ge3Rocm93IHttZXNzYWdlOiBlcnJ9fVxuXG4gICAgICAgIC8vIHN3aXRjaCBiYXNlIG9uIHdoYXQgY2FzZSB0aGUgdXNlciB0YWtlXG4gICAgICAgIGNvbnN0IG9wdHMgPSBvYmpGaXJzdEFyZyA/IG9iakZpcnN0QXJnIDogb3B0aW9uc1xuICAgICAgICBjb25zdCBvcHRzMiA9IHN0cmluZ0ZpcnN0QXJnID8gYWJzb2x1dGVQYXRoIDogb3B0c1xuICAgICAgICBjb25zdCBvcHRzMyA9IGNvbXBsZXRlQXJncyA/IG9wdGlvbnMgOiBvcHRzMlxuICAgICAgICBjb25zdCBvcHRzNCA9IGFsbFVuZGVmICYmIGxpYi5yb290UGF0aFxuICAgICAgICBjb25zdCBvcHRzUmVzID0gb3B0czQgPyBvcHRzNCA6IG9wdHMzXG4gICAgICAgIFxuICAgICAgICAvLyB0b2dnbGUgdHlwZXNcbiAgICAgICAgbGV0IGN1cnJlbnRUeXBlID0gJ29iamVjdCdcbiAgICAgICAgY29uc3QgY2hhbmdlVHlwZSA9ICh0eXBlKSA9PiBjdXJyZW50VHlwZSA9IHR5cGVcbiAgICAgICAgc3RyaW5nRmlyc3RBcmcgJiYgY2hhbmdlVHlwZSgnc3RyaW5nJylcbiAgICAgICAgY29tcGxldGVBcmdzICYmIGNoYW5nZVR5cGUoJ29iamVjdCcpXG4gICAgICAgIGFsbFVuZGVmICYmIGNoYW5nZVR5cGUoJ3N0cmluZycpXG5cbiAgICAgICAgLy8gVGhpcyB0aGUgb25seSBhdmFpbGFibGUgb3B0aW9ucywgdGhpcyBpcyB0aGUga2V5cyB0aGF0IHRoZSB1c2VyIHdpbGwgcHJvdmlkZVxuICAgICAgICBjb25zdCBvcHRpb25zQXJyYXkgPSBbJ2VuZHNXaXRoJywnc3RhcnRzV2l0aCcsJ3dpbGRDYXJkJ11cbiAgICAgICAgT2JqZWN0LnNlYWwob3B0aW9uc0FycmF5KVxuXG4gICAgICAgIC8vIHJvb3RQYXRoIGlzIG5vdCBzZXQgYW5kIGFic29sdXRlUGF0aCBpcyBub3RcbiAgICAgICAgbGliLnJvb3RQYXRoID09IHVuZGVmaW5lZCAmJiBhYnNvbHV0ZVBhdGggPT0gdW5kZWZpbmVkICYmIG9wdGlvbnNFcnIoYGxzOiBQYXRoIGNhbm5vdCBiZSB1bmRlZmluZWQsIGF0IGxlYXN0IHNldCBhIHJvb3RoUGF0aGApXG5cbiAgICAgICAgLy8gaWYgb3B0aW9uIGlzIG5vdCBhIHR5cGUgb2Ygb2JqZWN0IHRocm93IGFuIGVycm9yIHwgbHMoKVxuICAgICAgICB0eXBlb2Ygb3B0c1JlcyAhPSBjdXJyZW50VHlwZSAmJiBvcHRpb25zRXJyKGBsczogT3B0aW9ucyBzaG91bGQgYmUgYSB0eXBlIG9mICR7Y3VycmVudFR5cGV9IG9ubHlgKVxuXG4gICAgICAgIC8vIGlmIG9wdGlvbnMgb2JqZWN0IGlzIGVtcHR5IHRocm93IGFuIGVycm9yIHwgbHMoe30pXG4gICAgICAgIHR5cGVvZiBvcHRzID09IGN1cnJlbnRUeXBlICYmIE9iamVjdC5rZXlzKG9wdHMpLmxlbmd0aCA9PSAwICYmIG9wdGlvbnNFcnIoYGxpc3RFcnJvcjogT3B0aW9ucyAke2N1cnJlbnRUeXBlfSBjYW5ub3QgYmUgZW1wdHlgKVxuXG4gICAgICAgIC8vIGlmIG9wdGlvbnMgb2JqZWN0IGhhcyBtb3JlIHRoYW4gb25lIGtleSB0aHJvdyBhbiBlcnJvclxuICAgICAgICB0eXBlb2Ygb3B0cyA9PSBjdXJyZW50VHlwZSAmJiBPYmplY3Qua2V5cyhvcHRzKS5sZW5ndGggIT0gMSAmJiBvcHRpb25zRXJyKCdsaXN0RXJyb3I6IE9wdGlvbnMgb2JqZWN0IGNhbm5vdCBiZSBtb3JlIHRoYW4gb25lJylcblxuICAgICAgICAvLyB0eXBvIGluIHRoZSBvcHRpb25zIGtleVxuICAgICAgICB0eXBlb2Ygb3B0cyA9PSBjdXJyZW50VHlwZSAmJiBPYmplY3Qua2V5cyhvcHRzKS5sZW5ndGggPT0gMSAmJiBcbiAgICAgICAgb3B0aW9uc0FycmF5LmluZGV4T2YoT2JqZWN0LmtleXMob3B0cylbMF0pID09IC0xICYmIG9wdGlvbnNFcnIoYGxpc3RFcnJvcjogXCIke09iamVjdC5rZXlzKG9wdHMpWzBdfVwiIGlzIG5vdCByZWNvZ25pemVkLCBvcHRpb25zIGFyZSBcIiR7b3B0aW9uc0FycmF5fVwiYClcbiAgICAgICAgXG4gICAgICAgIC8vIGVtcHR5IHZhbHVlXG4gICAgICAgIHR5cGVvZiBvcHRzID09IGN1cnJlbnRUeXBlICYmIE9iamVjdC5rZXlzKG9wdHMpLmxlbmd0aCA9PSAxICYmXG4gICAgICAgIG9wdGlvbnNBcnJheS5pbmRleE9mKE9iamVjdC5rZXlzKG9wdHMpWzBdKSAhPSAtMSAmJiBvcHRzW09iamVjdC5rZXlzKG9wdHMpWzBdXSA9PSAnJyAmJiBcbiAgICAgICAgb3B0aW9uc0VycignbGlzdEVycm9yOiBPcHRpb25zIHZhbHVlIGNhbm5vdCBiZSBhbiBlbXB0eSBzdHJpbmcnKVxuXG4gICAgICAgIC8vIG5vdCBhIHN0cmluZyB2YWx1ZVxuICAgICAgICB0eXBlb2Ygb3B0cyA9PSAnb2JqZWN0JyAmJiBPYmplY3Qua2V5cyhvcHRzKS5sZW5ndGggPT0gMSAmJlxuICAgICAgICBvcHRpb25zQXJyYXkuaW5kZXhPZihPYmplY3Qua2V5cyhvcHRzKVswXSkgIT0gLTEgJiYgdHlwZW9mIG9wdHNbT2JqZWN0LmtleXMob3B0cylbMF1dICE9ICdzdHJpbmcnICYmIFxuICAgICAgICBvcHRpb25zRXJyKCdsaXN0RXJyb3I6IE9wdGlvbnMgdmFsdWUgdHlwZSBzaG91bGQgYmUgYSBzdHJpbmcnKVxuXG4gICAgICAgIC8vIENvbnRhaW5lciB0aGF0IHdpbGwgYmUgdXNlIHRvIGJlIG11dGF0ZWQgbGF0ZXIsIHVzZWQgdG8gZm9yIHJldHVybiBvZiB0aGUgZGF0YVxuICAgICAgICBsZXQgcmVzID0gdW5kZWZpbmVkXG5cbiAgICAgICAgLy8gcmV0dXJuZWQgbWV0aG9kc1xuICAgICAgICBsZXQgbWV0aG9kcyA9IHt9XG5cbiAgICAgICAgLy8gbW9kZXMgXG4gICAgICAgIGNvbnN0IG1vZGVzID0gWydhc2MnLCdkZWMnXVxuXG4gICAgICAgIC8vIFVzZURhdGFcbiAgICAgICAgbGV0IFVzZXJEYXRhID0gdW5kZWZpbmVkXG4gICAgICAgIG9iakZpcnN0QXJnICAgICAmJiAoVXNlckRhdGEgPSB7cGF0aDogbGliLnJvb3RQYXRoLCBvcHRpb25zOmFic29sdXRlUGF0aH0pXG4gICAgICAgIC8vIHN0cmluZ0ZpcnN0QXJnICAmJiAoVXNlckRhdGEgPSB7cGF0aDogYWJzb2x1dGVQYXRoLmVuZHNXaXRoKCcvJykgPyBhYnNvbHV0ZVBhdGggOiBgJHthYnNvbHV0ZVBhdGh9L2AsIG9wdGlvbnM6dW5kZWZpbmVkfSlcblxuICAgICAgICAvLyB3aGF0IGlmIGNkIGxpbmsgaGFzIHRoZSBzYW1lIGxpbmsgYXMgbHMgPyBcbiAgICAgICAgY29uc3Qgc3RyRmlyc3RBcmdDMSA9IHR5cGVvZiBsaWIucm9vdFBhdGggPT0gJ3N0cmluZycgJiYgdHlwZW9mIGFic29sdXRlUGF0aCA9PSAnc3RyaW5nJ1xuICAgICAgICBjb25zdCBzdHJGaXJzdEFyZ0MyID0gc3RyRmlyc3RBcmdDMSAmJiBsaWIucm9vdFBhdGggPT0gYWJzb2x1dGVQYXRoID8gdHJ1ZSA6IGZhbHNlXG4gICAgICAgIGNvbnN0IHN0ckZpcnN0QXJnQzMgPSBzdHJGaXJzdEFyZ0MyID8gYWJzb2x1dGVQYXRoIDogYCR7bGliLnJvb3RQYXRoID09IHVuZGVmaW5lZCA/ICcnIDogbGliLnJvb3RQYXRofSR7YWJzb2x1dGVQYXRofWBcblxuICAgICAgICAvLyBhc3NpZ24gY29ycmVjdCBkYXRhXG4gICAgICAgIHN0cmluZ0ZpcnN0QXJnICAmJiAoVXNlckRhdGEgPSB7cGF0aDogc3RyRmlyc3RBcmdDMy5lbmRzV2l0aCgnLycpID8gc3RyRmlyc3RBcmdDMyA6IGAke3N0ckZpcnN0QXJnQzN9L2AsIG9wdGlvbnM6dW5kZWZpbmVkfSlcbiAgICAgICAgY29tcGxldGVBcmdzICAgICYmIChVc2VyRGF0YSA9IHtwYXRoOiBzdHJGaXJzdEFyZ0MzLmVuZHNXaXRoKCcvJykgPyBzdHJGaXJzdEFyZ0MzIDogYCR7c3RyRmlyc3RBcmdDM30vYCwgb3B0aW9uc30pXG4gICAgICAgIGFsbFVuZGVmICAgICAgICAmJiAoVXNlckRhdGEgPSB7cGF0aDogbGliLnJvb3RQYXRoLCBvcHRpb25zOm9wdGlvbnN9KVxuXG4gICAgICAgIC8vIENvbnRlbnRzXG4gICAgICAgIGxldCBjb250ZW50cyA9IFtdXG4gICAgICAgIGNvbnN0IGRvZXNQYXRoRXhpc3QgPSBmcy5leGlzdHNTeW5jKFVzZXJEYXRhLnBhdGgpXG4gICAgICAgIGlmKCFkb2VzUGF0aEV4aXN0KXt0aHJvdyBuZXcgUGF0aERvZXNOb3RFeGlzdEVycm9yKGBvbiBsczogbm8gc3VjaCBkaXJlY3RvcnkgJHtVc2VyRGF0YS5wYXRofWApfVxuICAgICAgICBkb2VzUGF0aEV4aXN0ICYmIHNldEMoVXNlckRhdGEucGF0aClcblxuICAgICAgICByZXR1cm4gY2RcbiAgICB9XG5cbiAgICAvL1xuICAgIGxpYi50b3VjaCA9IChmaWxlKSA9PiB7XG4gICAgICAgIC8vIHNhbml0aXppbmdcbiAgICAgICAgZmlsZSA9PSB1bmRlZmluZWQgJiYgZXJyKCdlcnJvciB0b3VjaDogdG91Y2ggcGFyYW1ldGVyIGNhbm5vdCBiZSB1bmRlZmluZWQnKVxuICAgICAgICB0eXBlb2YgZmlsZSAhPSAnc3RyaW5nJyAmJiBmaWxlWzBdID09IHVuZGVmaW5lZCAmJiBlcnIoJ2Vycm9yIHRvdWNoOiBpbnZhbGlkIHRweWUgaW4gcGFyYW1ldGVyIHNob3VsZCBiZSBhIHN0cmluZyBvciBhcnJheScpXG5cblxuICAgICAgICBjb25zdCBjMSA9ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG9yaWdpblBhdGggPSBPYmplY3Qua2V5cyggcXVlcnlTdHJpbmcucGFyc2UoZmlsZSwnLycpIClcbiAgICAgICAgICAgIGNvbnN0IHBhdGhMZW4gPSBvcmlnaW5QYXRoLmxlbmd0aCAtIDFcbiAgICAgICAgICAgIGNvbnN0IHBhdGhGaWxlID0gYC8ke29yaWdpblBhdGguc3BsaWNlKHBhdGhMZW4sMSlbMF19YFxuICAgICAgICAgICAgb3JpZ2luUGF0aC5zcGxpY2UocGF0aExlbiwxKVxuICAgICAgICAgICAgbGV0IG5ld1BhdGggPSAnJ1xuICAgICAgICAgICAgb3JpZ2luUGF0aC5tYXAoZSA9PiBuZXdQYXRoICs9IGAvJHtlfWApXG5cbiAgICAgICAgICAgICFmcy5leGlzdHNTeW5jKG5ld1BhdGgpID8gZXJyKGB0aGVyZSBpcyBubyBzdWNoIGRpcmVjdG9yeSAke25ld1BhdGh9YCkgOiBmcy53cml0ZUZpbGVTeW5jKGAke25ld1BhdGh9JHtwYXRoRmlsZX1gKVxuICAgICAgICAgICAgY29uc29sZS5sb2coYCR7bmV3UGF0aH0ke3BhdGhGaWxlfWApXG4gICAgICAgIH1cblxuICAgICAgICBjMSgpXG4gICAgICAgIFxuICAgICAgICAvLyBjb25zb2xlLmxvZyhgJHtmaWxlfSAtLT4gJHtsaWIucm9vdFBhdGh9YClcbiAgICAgICAgXG4gICAgICAgIC8vIGNoZWNraW5nIGV4aXN0YW5jY2VcbiAgICAgICAgXG4gICAgfVxuXG4gICAgLy8gYy4gbWtkaXIgY3JlYXRlcyBuZXcgZGlyZWN0b3J5XG4gICAgLy8gYy5jYXNlcyA6IG1rZGlyKFtdKSAtLT4gYWNjZXB0cyBhcnJheSBhcyBhbiBhcnVndW1lbnQgYXMgZm9sZGVyIG5hbWVzIHwgbWFzcyBmb2xkZXIgY3JlYXRpb25cbiAgICAvLyBjLmNhc2VzIDogbWtkaXIoJycpIC0tPiBhY2NlcHRzIHN0cmluZyB8IHNpbmdsZSBkaXIgY3JlYXRpb25cbiAgICBsaWIubWtkaXIgPSAocGF0aCkgPT4ge1xuXG4gICAgfVxuXG4gICAgZGVsZXRlIGxpYi5yb290UGF0aFxuICAgIHJldHVybiBsaWJcbn0pKClcblxubW9kdWxlLmV4cG9ydHMgPSBkIl19