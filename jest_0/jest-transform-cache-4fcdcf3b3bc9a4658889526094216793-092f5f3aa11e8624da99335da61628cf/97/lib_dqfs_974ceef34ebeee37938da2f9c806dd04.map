{"version":3,"sources":["lib_dqfs.js"],"names":["fs","require","queryString","d","dir","name","undefined","publicPath","parentDir","label","items","size","type","fileAccess","birttime","lib","cd","rootPath","ArgsParamTypeError","message","PathDoesNotExistError","ERROR","err","isUndef","val","fnName","y","forEach","el","push","indexOf","isType","types","t","isEmpty","fn","getSize","path","totalSize","recur","isThereADir","lstatSync","isDirectory","readdirSync","length","map","e","getChildPaths","children","files","isD","statSync","setC","T","newA","child","G","Object","create","birthtime","folderAccess","Layer","data","beforeEnter","hasEntered","onExit","bE","oE","sanitizedPath","endsWith","existsSync","ls","absolutePath","options","objFirstArg","stringFirstArg","completeArgs","allUndef","optionsErr","opts","opts2","opts3","opts4","optsRes","currentType","changeType","optionsArray","seal","keys","res","methods","modes","UserData","strFirstArgC1","strFirstArgC2","strFirstArgC3","contents","doesPathExist","touch","file","c1","originPath","parse","pathLen","pathFile","splice","newPath","writeFileSync","console","log","mkdir","module","exports"],"mappings":"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","file":"lib_dqfs.js","sourcesContent":["\"use strict\"\n\nconst fs = require('fs')\nconst queryString = require('querystring')\nconst d = (() => {\n// Current Data set \n    const dir = {\n        name: undefined,\n        publicPath: undefined,\n        parentDir: undefined,\n        label: undefined,\n        items: undefined,\n        size: undefined,\n        type: undefined, // directory or file\n        fileAccess: undefined,\n        birttime: undefined,\n    }\n// init empty lib\n    let lib = {}\n    let cd = undefined\n    lib.rootPath = undefined\n// Utils\n    function ArgsParamTypeError(message) {\n        this.message = message\n    }\n    function PathDoesNotExistError(message) {\n        this.message = message\n    }\n    function ERROR(message){\n        this.message = message\n    }\n    function err(message) {\n        throw new ERROR(message)\n    }\n    function isUndef(val,fnName){\n        let y = []\n        val.forEach(el => {\n            y.push(el == undefined)\n        })\n        if(y.indexOf(true) != -1){\n            throw{\n                message: `${fnName} function arg position ${y.indexOf(true)} cannot be undefined`\n            }\n        }\n    }\n    function isType(types,fnName,t){\n        isUndef([types,fnName,t],fnName)\n\n        if(types.indexOf(false) == -1){\n            return true\n        }else{\n            throw new ArgsParamTypeError(\n                `on ${fnName}() function argument position (${types.indexOf(false) + 1}) cannot be undefined should be a ${t[types.indexOf(false)]}`\n            )\n        }\n    }\n    function isEmpty(val,fn){\n        if(val == ''){\n            throw {\n                message: `${fn} function cannot take an empty string as an argument`\n            }\n        }\n    }\n    function getSize(path){\n        let totalSize  = 0   \n\n        // recursion\n        const recur = path => {\n            let isThereADir = []\n            fs.lstatSync(path).isDirectory() ? (isThereADir = fs.readdirSync(path)) : totalSize += fs.lstatSync(path).size\n            isThereADir.length != 0 && isThereADir.map(e => recur(`${path}/${e}`))\n        }\n        \n        // initial call\n        recur(path)\n        \n        return totalSize\n    }\n    function getChildPaths(path){\n        let children = {\n            dir: [],\n            files: []\n        }\n        const isD = fs.statSync(path).isDirectory() ? true : false\n        const items = isD ? fs.readdirSync(path) : path        \n        typeof items == 'object' ? items.map(e => children.dir.push(`${path}${e}`)) : children.files.push(items)\n        return children\n    }\n    function setC(T){\n        let newA = []\n        cd = fs.readdirSync(T)\n        cd.forEach(child => {\n            const G = Object.create(dir)\n            G.name = child\n            G.publicPath = `${T}${child}`\n            G.parentDir = T\n            G.label = 'none'\n            G.items = fs.lstatSync(`${T}${child}`).isDirectory() ? G.items = fs.readdirSync(`${T}${child}`).length : G.items = 'none'\n            G.size = getSize(`${T}${child}`)\n            G.birthtime = fs.lstatSync(T).birthtime\n            G.type = fs.lstatSync(`${T}/${child}`).isDirectory() ? 'folder/directory' : 'file/application'\n            G.children = getChildPaths(`${T}${child}`).length == 0 ? 'none' : getChildPaths(`${T}${child}`)\n            G.fileAccess = 'rw+'\n            if(fs.lstatSync( `${T}${child}` ).isDirectory() ){\n                delete G.fileAccess\n                G.folderAccess = 'rw+'\n            }else{\n                delete G.items\n                G.fileAccess = 'rw+'\n            }\n            newA.push(G)\n        })\n        cd = newA\n    }\n    const Layer = function(data,{beforeEnter,hasEntered,onExit}) {\n        const bE = beforeEnter(data)\n        const oE = hasEntered(bE)\n        onExit(oE)\n    }\n// libs\n    \n    // a. set rooth path directory\n    lib.cd = (path) => {        \n        isType([\n            [typeof path] == 'string'\n        ],'cd',['string'])\n        isEmpty(path,'cd')\n        \n        const sanitizedPath = path.endsWith('/') ? path : `${path}/`\n        \n        if(fs.existsSync(sanitizedPath)){            \n            lib.rootPath = sanitizedPath\n            setC(sanitizedPath)\n        }else{\n            throw{\n                message: `cd: no such directory ${sanitizedPath}`\n            }\n        }        \n        return true\n    }\n    \n    // b. retunrs an array of properties, of folder contents\n    lib.ls = (absolutePath,options) => {\n        // case 1, absolutepath is object, so the path that well be used\n        //         to travers the directory is the cd path,\n        //         it is expected that the object has object keys for options array\n        const objFirstArg = typeof absolutePath == 'object' && options == undefined && absolutePath\n\n        // case 2, absolutepath is string, it means the user provided an absolute path\n        //         which means the cd path if it is being set will be ignored\n        const stringFirstArg = typeof absolutePath == 'string' && options == undefined && true\n\n        // case 3, \n        const completeArgs = typeof absolutePath == 'string' && typeof options == 'object'\n\n        // case 4\n        const allUndef = absolutePath == undefined && options == undefined\n\n        // options error\n        const optionsErr = (err) => {throw {message: err}}\n\n        // switch base on what case the user take\n        const opts = objFirstArg ? objFirstArg : options\n        const opts2 = stringFirstArg ? absolutePath : opts\n        const opts3 = completeArgs ? options : opts2\n        const opts4 = allUndef && lib.rootPath\n        const optsRes = opts4 ? opts4 : opts3\n        \n        // toggle types\n        let currentType = 'object'\n        const changeType = (type) => currentType = type\n        stringFirstArg && changeType('string')\n        completeArgs && changeType('object')\n        allUndef && changeType('string')\n\n        // This the only available options, this is the keys that the user will provide\n        const optionsArray = ['endsWith','startsWith','wildCard']\n        Object.seal(optionsArray)\n\n        // rootPath is not set and absolutePath is not\n        lib.rootPath == undefined && absolutePath == undefined && optionsErr(`ls: Path cannot be undefined, at least set a roothPath`)\n\n        // if option is not a type of object throw an error | ls()\n        typeof optsRes != currentType && optionsErr(`ls: Options should be a type of ${currentType} only`)\n\n        // if options object is empty throw an error | ls({})\n        typeof opts == currentType && Object.keys(opts).length == 0 && optionsErr(`listError: Options ${currentType} cannot be empty`)\n\n        // if options object has more than one key throw an error\n        typeof opts == currentType && Object.keys(opts).length != 1 && optionsErr('listError: Options object cannot be more than one')\n\n        // typo in the options key\n        typeof opts == currentType && Object.keys(opts).length == 1 && \n        optionsArray.indexOf(Object.keys(opts)[0]) == -1 && optionsErr(`listError: \"${Object.keys(opts)[0]}\" is not recognized, options are \"${optionsArray}\"`)\n        \n        // empty value\n        typeof opts == currentType && Object.keys(opts).length == 1 &&\n        optionsArray.indexOf(Object.keys(opts)[0]) != -1 && opts[Object.keys(opts)[0]] == '' && \n        optionsErr('listError: Options value cannot be an empty string')\n\n        // not a string value\n        typeof opts == 'object' && Object.keys(opts).length == 1 &&\n        optionsArray.indexOf(Object.keys(opts)[0]) != -1 && typeof opts[Object.keys(opts)[0]] != 'string' && \n        optionsErr('listError: Options value type should be a string')\n\n        // Container that will be use to be mutated later, used to for return of the data\n        let res = undefined\n\n        // returned methods\n        let methods = {}\n\n        // modes \n        const modes = ['asc','dec']\n\n        // UseData\n        let UserData = undefined\n        objFirstArg     && (UserData = {path: lib.rootPath, options:absolutePath})\n        // stringFirstArg  && (UserData = {path: absolutePath.endsWith('/') ? absolutePath : `${absolutePath}/`, options:undefined})\n\n        // what if cd link has the same link as ls ? \n        const strFirstArgC1 = typeof lib.rootPath == 'string' && typeof absolutePath == 'string'\n        const strFirstArgC2 = strFirstArgC1 && lib.rootPath == absolutePath ? true : false\n        const strFirstArgC3 = strFirstArgC2 ? absolutePath : `${lib.rootPath == undefined ? '' : lib.rootPath}${absolutePath}`\n\n        // assign correct data\n        stringFirstArg  && (UserData = {path: strFirstArgC3.endsWith('/') ? strFirstArgC3 : `${strFirstArgC3}/`, options:undefined})\n        completeArgs    && (UserData = {path: strFirstArgC3.endsWith('/') ? strFirstArgC3 : `${strFirstArgC3}/`, options})\n        allUndef        && (UserData = {path: lib.rootPath, options:options})\n\n        // Contents\n        let contents = []\n        const doesPathExist = fs.existsSync(UserData.path)\n        if(!doesPathExist){throw new PathDoesNotExistError(`on ls: no such directory ${UserData.path}`)}\n        doesPathExist && setC(UserData.path)\n\n        return cd\n    }\n\n    //\n    lib.touch = (file) => {\n        // sanitizing\n        file == undefined && err('error touch: touch parameter cannot be undefined')\n        typeof file != 'string' && file[0] == undefined && err('error touch: invalid tpye in parameter should be a string or array')\n\n\n        const c1 = () => {\n            const originPath = Object.keys( queryString.parse(file,'/') )\n            const pathLen = originPath.length - 1\n            const pathFile = `/${originPath.splice(pathLen,1)[0]}`\n            originPath.splice(pathLen,1)\n            let newPath = ''\n            originPath.map(e => newPath += `/${e}`)\n\n            !fs.existsSync(newPath) ? err(`there is no such directory ${newPath}`) : fs.writeFileSync(`${newPath}${pathFile}`)\n            console.log(`${newPath}${pathFile}`)\n        }\n\n        c1()\n        \n        // console.log(`${file} --> ${lib.rootPath}`)\n        \n        // checking existancce\n        \n    }\n\n    // c. mkdir creates new directory\n    // c.cases : mkdir([]) --> accepts array as an arugument as folder names | mass folder creation\n    // c.cases : mkdir('') --> accepts string | single dir creation\n    lib.mkdir = (path) => {\n\n    }\n\n    delete lib.rootPath\n    return lib\n})()\n\nmodule.exports = d"]}