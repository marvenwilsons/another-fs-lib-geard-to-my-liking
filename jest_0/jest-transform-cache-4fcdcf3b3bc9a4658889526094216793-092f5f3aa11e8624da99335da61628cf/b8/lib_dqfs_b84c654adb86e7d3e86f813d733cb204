f382dc3e7f241ee8692052df7906cbe2
"use strict";

const fs = require('fs');
const queryString = require('querystring');
const d = (() => {
    // Current Data set 
    const dir = {
        name: undefined,
        publicPath: undefined,
        parentDir: undefined,
        label: undefined,
        items: undefined,
        size: undefined,
        type: undefined, // directory or file
        fileAccess: undefined,
        birttime: undefined
        // init empty lib
    };let lib = {};
    let cd = undefined;
    lib.rootPath = undefined;
    // Utils
    function ArgsParamTypeError(message) {
        this.message = message;
    }
    function PathDoesNotExistError(message) {
        this.message = message;
    }
    function ERROR(message) {
        this.message = message;
    }
    function err(message) {
        throw new ERROR(message);
    }
    function isUndef(val, fnName) {
        let y = [];
        val.forEach(el => {
            y.push(el == undefined);
        });
        if (y.indexOf(true) != -1) {
            throw {
                message: `${fnName} function arg position ${y.indexOf(true)} cannot be undefined`
            };
        }
    }
    function isType(types, fnName, t) {
        isUndef([types, fnName, t], fnName);

        if (types.indexOf(false) == -1) {
            return true;
        } else {
            throw new ArgsParamTypeError(`on ${fnName}() function argument position (${types.indexOf(false) + 1}) cannot be undefined should be a ${t[types.indexOf(false)]}`);
        }
    }
    function isEmpty(val, fn) {
        if (val == '') {
            throw {
                message: `${fn} function cannot take an empty string as an argument`
            };
        }
    }
    function getSize(path) {
        let totalSize = 0;

        // recursion
        const recur = path => {
            let isThereADir = [];
            fs.lstatSync(path).isDirectory() ? isThereADir = fs.readdirSync(path) : totalSize += fs.lstatSync(path).size;
            isThereADir.length != 0 && isThereADir.map(e => recur(`${path}/${e}`));
        };

        // initial call
        recur(path);

        return totalSize;
    }
    function getChildPaths(path) {
        let children = {
            dir: [],
            files: []
        };
        const isD = fs.statSync(path).isDirectory() ? true : false;
        const items = isD ? fs.readdirSync(path) : path;
        typeof items == 'object' ? items.map(e => children.dir.push(`${path}${e}`)) : children.files.push(items);
        return children;
    }
    function setC(T) {
        let newA = [];
        cd = fs.readdirSync(T);
        cd.forEach(child => {
            const G = Object.create(dir);
            G.name = child;
            G.publicPath = `${T}${child}`;
            G.parentDir = T;
            G.label = 'none';
            G.items = fs.lstatSync(`${T}${child}`).isDirectory() ? G.items = fs.readdirSync(`${T}${child}`).length : G.items = 'none';
            G.size = getSize(`${T}${child}`);
            G.birthtime = fs.lstatSync(T).birthtime;
            G.type = fs.lstatSync(`${T}/${child}`).isDirectory() ? 'folder/directory' : 'file/application';
            G.children = getChildPaths(`${T}${child}`).length == 0 ? 'none' : getChildPaths(`${T}${child}`);
            G.fileAccess = 'rw+';
            if (fs.lstatSync(`${T}${child}`).isDirectory()) {
                delete G.fileAccess;
                G.folderAccess = 'rw+';
            } else {
                delete G.items;
                G.fileAccess = 'rw+';
            }
            newA.push(G);
        });
        cd = newA;
    }
    const Layer = function (data, { beforeEnter, hasEntered, onExit }) {
        const bE = beforeEnter(data);
        const oE = hasEntered(bE);
        onExit(oE);
    };
    // libs

    // a. set rooth path directory
    lib.cd = path => {
        isType([[typeof path] == 'string'], 'cd', ['string']);
        isEmpty(path, 'cd');

        const sanitizedPath = path.endsWith('/') ? path : `${path}/`;

        if (fs.existsSync(sanitizedPath)) {
            lib.rootPath = sanitizedPath;
            setC(sanitizedPath);
        } else {
            throw {
                message: `cd: no such directory ${sanitizedPath}`
            };
        }
        return true;
    };

    // b. retunrs an array of properties, of folder contents
    lib.ls = (absolutePath, options) => {
        // case 1, absolutepath is object, so the path that well be used
        //         to travers the directory is the cd path,
        //         it is expected that the object has object keys for options array
        const objFirstArg = typeof absolutePath == 'object' && options == undefined && absolutePath;

        // case 2, absolutepath is string, it means the user provided an absolute path
        //         which means the cd path if it is being set will be ignored
        const stringFirstArg = typeof absolutePath == 'string' && options == undefined && true;

        // case 3, 
        const completeArgs = typeof absolutePath == 'string' && typeof options == 'object';

        // case 4
        const allUndef = absolutePath == undefined && options == undefined;

        // options error
        const optionsErr = err => {
            throw { message: err };
        };

        // switch base on what case the user take
        const opts = objFirstArg ? objFirstArg : options;
        const opts2 = stringFirstArg ? absolutePath : opts;
        const opts3 = completeArgs ? options : opts2;
        const opts4 = allUndef && lib.rootPath;
        const optsRes = opts4 ? opts4 : opts3;

        // toggle types
        let currentType = 'object';
        const changeType = type => currentType = type;
        stringFirstArg && changeType('string');
        completeArgs && changeType('object');
        allUndef && changeType('string');

        // This the only available options, this is the keys that the user will provide
        const optionsArray = ['endsWith', 'startsWith', 'wildCard'];
        Object.seal(optionsArray);

        // rootPath is not set and absolutePath is not
        lib.rootPath == undefined && absolutePath == undefined && optionsErr(`ls: Path cannot be undefined, at least set a roothPath`);

        // if option is not a type of object throw an error | ls()
        typeof optsRes != currentType && optionsErr(`ls: Options should be a type of ${currentType} only`);

        // if options object is empty throw an error | ls({})
        typeof opts == currentType && Object.keys(opts).length == 0 && optionsErr(`listError: Options ${currentType} cannot be empty`);

        // if options object has more than one key throw an error
        typeof opts == currentType && Object.keys(opts).length != 1 && optionsErr('listError: Options object cannot be more than one');

        // typo in the options key
        typeof opts == currentType && Object.keys(opts).length == 1 && optionsArray.indexOf(Object.keys(opts)[0]) == -1 && optionsErr(`listError: "${Object.keys(opts)[0]}" is not recognized, options are "${optionsArray}"`);

        // empty value
        typeof opts == currentType && Object.keys(opts).length == 1 && optionsArray.indexOf(Object.keys(opts)[0]) != -1 && opts[Object.keys(opts)[0]] == '' && optionsErr('listError: Options value cannot be an empty string');

        // not a string value
        typeof opts == 'object' && Object.keys(opts).length == 1 && optionsArray.indexOf(Object.keys(opts)[0]) != -1 && typeof opts[Object.keys(opts)[0]] != 'string' && optionsErr('listError: Options value type should be a string');

        // Container that will be use to be mutated later, used to for return of the data
        let res = undefined;

        // returned methods
        let methods = {};

        // modes 
        const modes = ['asc', 'dec'];

        // UseData
        let UserData = undefined;
        objFirstArg && (UserData = { path: lib.rootPath, options: absolutePath });
        // stringFirstArg  && (UserData = {path: absolutePath.endsWith('/') ? absolutePath : `${absolutePath}/`, options:undefined})

        // what if cd link has the same link as ls ? 
        const strFirstArgC1 = typeof lib.rootPath == 'string' && typeof absolutePath == 'string';
        const strFirstArgC2 = strFirstArgC1 && lib.rootPath == absolutePath ? true : false;
        const strFirstArgC3 = strFirstArgC2 ? absolutePath : `${lib.rootPath == undefined ? '' : lib.rootPath}${absolutePath}`;

        // assign correct data
        stringFirstArg && (UserData = { path: strFirstArgC3.endsWith('/') ? strFirstArgC3 : `${strFirstArgC3}/`, options: undefined });
        completeArgs && (UserData = { path: strFirstArgC3.endsWith('/') ? strFirstArgC3 : `${strFirstArgC3}/`, options });
        allUndef && (UserData = { path: lib.rootPath, options: options });

        // Contents
        let contents = [];
        const doesPathExist = fs.existsSync(UserData.path);
        if (!doesPathExist) {
            throw new PathDoesNotExistError(`on ls: no such directory ${UserData.path}`);
        }
        doesPathExist && setC(UserData.path);

        return cd;
    };

    //
    lib.touch = file => {
        // sanitizing
        file == undefined && err('error touch: touch parameter cannot be undefined');
        typeof file != 'string' && file[0] == undefined && err('error touch: invalid tpye in parameter should be a string or array');

        const c1 = () => {
            const originPath = Object.keys(queryString.parse(file, '/'));
            const pathLen = originPath.length - 1;
            const pathFile = `/${originPath.splice(pathLen, 1)[0]}`;
            originPath.splice(pathLen, 1);
            let newPath = '';
            originPath.map(e => newPath += `/${e}`);

            fs.existsSync(newPath) ? fs.existsSync(`${newPath}${pathFile}`) ? err(`${pathFile} already exist in ${newPath} directory`) : fs.writeFileSync(`${newPath}${pathFile}`) : err(`there is no such directory ${newPath}`);

            console.log(`${newPath}${pathFile}`);
        };

        c1();

        // console.log(`${file} --> ${lib.rootPath}`)

        // checking existancce
    };

    // c. mkdir creates new directory
    // c.cases : mkdir([]) --> accepts array as an arugument as folder names | mass folder creation
    // c.cases : mkdir('') --> accepts string | single dir creation
    lib.mkdir = path => {};

    delete lib.rootPath;
    return lib;
})();

module.exports = d;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYl9kcWZzLmpzIl0sIm5hbWVzIjpbImZzIiwicmVxdWlyZSIsInF1ZXJ5U3RyaW5nIiwiZCIsImRpciIsIm5hbWUiLCJ1bmRlZmluZWQiLCJwdWJsaWNQYXRoIiwicGFyZW50RGlyIiwibGFiZWwiLCJpdGVtcyIsInNpemUiLCJ0eXBlIiwiZmlsZUFjY2VzcyIsImJpcnR0aW1lIiwibGliIiwiY2QiLCJyb290UGF0aCIsIkFyZ3NQYXJhbVR5cGVFcnJvciIsIm1lc3NhZ2UiLCJQYXRoRG9lc05vdEV4aXN0RXJyb3IiLCJFUlJPUiIsImVyciIsImlzVW5kZWYiLCJ2YWwiLCJmbk5hbWUiLCJ5IiwiZm9yRWFjaCIsImVsIiwicHVzaCIsImluZGV4T2YiLCJpc1R5cGUiLCJ0eXBlcyIsInQiLCJpc0VtcHR5IiwiZm4iLCJnZXRTaXplIiwicGF0aCIsInRvdGFsU2l6ZSIsInJlY3VyIiwiaXNUaGVyZUFEaXIiLCJsc3RhdFN5bmMiLCJpc0RpcmVjdG9yeSIsInJlYWRkaXJTeW5jIiwibGVuZ3RoIiwibWFwIiwiZSIsImdldENoaWxkUGF0aHMiLCJjaGlsZHJlbiIsImZpbGVzIiwiaXNEIiwic3RhdFN5bmMiLCJzZXRDIiwiVCIsIm5ld0EiLCJjaGlsZCIsIkciLCJPYmplY3QiLCJjcmVhdGUiLCJiaXJ0aHRpbWUiLCJmb2xkZXJBY2Nlc3MiLCJMYXllciIsImRhdGEiLCJiZWZvcmVFbnRlciIsImhhc0VudGVyZWQiLCJvbkV4aXQiLCJiRSIsIm9FIiwic2FuaXRpemVkUGF0aCIsImVuZHNXaXRoIiwiZXhpc3RzU3luYyIsImxzIiwiYWJzb2x1dGVQYXRoIiwib3B0aW9ucyIsIm9iakZpcnN0QXJnIiwic3RyaW5nRmlyc3RBcmciLCJjb21wbGV0ZUFyZ3MiLCJhbGxVbmRlZiIsIm9wdGlvbnNFcnIiLCJvcHRzIiwib3B0czIiLCJvcHRzMyIsIm9wdHM0Iiwib3B0c1JlcyIsImN1cnJlbnRUeXBlIiwiY2hhbmdlVHlwZSIsIm9wdGlvbnNBcnJheSIsInNlYWwiLCJrZXlzIiwicmVzIiwibWV0aG9kcyIsIm1vZGVzIiwiVXNlckRhdGEiLCJzdHJGaXJzdEFyZ0MxIiwic3RyRmlyc3RBcmdDMiIsInN0ckZpcnN0QXJnQzMiLCJjb250ZW50cyIsImRvZXNQYXRoRXhpc3QiLCJ0b3VjaCIsImZpbGUiLCJjMSIsIm9yaWdpblBhdGgiLCJwYXJzZSIsInBhdGhMZW4iLCJwYXRoRmlsZSIsInNwbGljZSIsIm5ld1BhdGgiLCJ3cml0ZUZpbGVTeW5jIiwiY29uc29sZSIsImxvZyIsIm1rZGlyIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUEsTUFBTUEsS0FBS0MsUUFBUSxJQUFSLENBQVg7QUFDQSxNQUFNQyxjQUFjRCxRQUFRLGFBQVIsQ0FBcEI7QUFDQSxNQUFNRSxJQUFJLENBQUMsTUFBTTtBQUNqQjtBQUNJLFVBQU1DLE1BQU07QUFDUkMsY0FBTUMsU0FERTtBQUVSQyxvQkFBWUQsU0FGSjtBQUdSRSxtQkFBV0YsU0FISDtBQUlSRyxlQUFPSCxTQUpDO0FBS1JJLGVBQU9KLFNBTEM7QUFNUkssY0FBTUwsU0FORTtBQU9STSxjQUFNTixTQVBFLEVBT1M7QUFDakJPLG9CQUFZUCxTQVJKO0FBU1JRLGtCQUFVUjtBQUVsQjtBQVhnQixLQUFaLENBWUEsSUFBSVMsTUFBTSxFQUFWO0FBQ0EsUUFBSUMsS0FBS1YsU0FBVDtBQUNBUyxRQUFJRSxRQUFKLEdBQWVYLFNBQWY7QUFDSjtBQUNJLGFBQVNZLGtCQUFULENBQTRCQyxPQUE1QixFQUFxQztBQUNqQyxhQUFLQSxPQUFMLEdBQWVBLE9BQWY7QUFDSDtBQUNELGFBQVNDLHFCQUFULENBQStCRCxPQUEvQixFQUF3QztBQUNwQyxhQUFLQSxPQUFMLEdBQWVBLE9BQWY7QUFDSDtBQUNELGFBQVNFLEtBQVQsQ0FBZUYsT0FBZixFQUF1QjtBQUNuQixhQUFLQSxPQUFMLEdBQWVBLE9BQWY7QUFDSDtBQUNELGFBQVNHLEdBQVQsQ0FBYUgsT0FBYixFQUFzQjtBQUNsQixjQUFNLElBQUlFLEtBQUos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RUYsUUFBUyxFQUFwQyxJQUF5Q2xGLElBQUssR0FBRWtGLFFBQVMscUJBQW9CRSxPQUFRLFlBQTVDLENBQXpDLEdBQ0ExRyxHQUFHMkcsYUFBSCxDQUFrQixHQUFFRCxPQUFRLEdBQUVGLFFBQVMsRUFBdkMsQ0FGSixHQUdHbEYsSUFBSyw4QkFBNkJvRixPQUFRLEVBQTFDLENBSEg7O0FBS0FFLG9CQUFRQyxHQUFSLENBQWEsR0FBRUgsT0FBUSxHQUFFRixRQUFTLEVBQWxDO0FBQ0gsU0FkRDs7QUFnQkFKOztBQUVBOztBQUVBO0FBRUgsS0E1QkQ7O0FBOEJBO0FBQ0E7QUFDQTtBQUNBckYsUUFBSStGLEtBQUosR0FBYXpFLElBQUQsSUFBVSxDQUVyQixDQUZEOztBQUlBLFdBQU90QixJQUFJRSxRQUFYO0FBQ0EsV0FBT0YsR0FBUDtBQUNILENBbFJTLEdBQVY7O0FBb1JBZ0csT0FBT0MsT0FBUCxHQUFpQjdHLENBQWpCIiwiZmlsZSI6ImxpYl9kcWZzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCJcblxuY29uc3QgZnMgPSByZXF1aXJlKCdmcycpXG5jb25zdCBxdWVyeVN0cmluZyA9IHJlcXVpcmUoJ3F1ZXJ5c3RyaW5nJylcbmNvbnN0IGQgPSAoKCkgPT4ge1xuLy8gQ3VycmVudCBEYXRhIHNldCBcbiAgICBjb25zdCBkaXIgPSB7XG4gICAgICAgIG5hbWU6IHVuZGVmaW5lZCxcbiAgICAgICAgcHVibGljUGF0aDogdW5kZWZpbmVkLFxuICAgICAgICBwYXJlbnREaXI6IHVuZGVmaW5lZCxcbiAgICAgICAgbGFiZWw6IHVuZGVmaW5lZCxcbiAgICAgICAgaXRlbXM6IHVuZGVmaW5lZCxcbiAgICAgICAgc2l6ZTogdW5kZWZpbmVkLFxuICAgICAgICB0eXBlOiB1bmRlZmluZWQsIC8vIGRpcmVjdG9yeSBvciBmaWxlXG4gICAgICAgIGZpbGVBY2Nlc3M6IHVuZGVmaW5lZCxcbiAgICAgICAgYmlydHRpbWU6IHVuZGVmaW5lZCxcbiAgICB9XG4vLyBpbml0IGVtcHR5IGxpYlxuICAgIGxldCBsaWIgPSB7fVxuICAgIGxldCBjZCA9IHVuZGVmaW5lZFxuICAgIGxpYi5yb290UGF0aCA9IHVuZGVmaW5lZFxuLy8gVXRpbHNcbiAgICBmdW5jdGlvbiBBcmdzUGFyYW1UeXBlRXJyb3IobWVzc2FnZSkge1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlXG4gICAgfVxuICAgIGZ1bmN0aW9uIFBhdGhEb2VzTm90RXhpc3RFcnJvcihtZXNzYWdlKSB7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2VcbiAgICB9XG4gICAgZnVuY3Rpb24gRVJST1IobWVzc2FnZSl7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2VcbiAgICB9XG4gICAgZnVuY3Rpb24gZXJyKG1lc3NhZ2UpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVSUk9SKG1lc3NhZ2UpXG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzVW5kZWYodmFsLGZuTmFtZSl7XG4gICAgICAgIGxldCB5ID0gW11cbiAgICAgICAgdmFsLmZvckVhY2goZWwgPT4ge1xuICAgICAgICAgICAgeS5wdXNoKGVsID09IHVuZGVmaW5lZClcbiAgICAgICAgfSlcbiAgICAgICAgaWYoeS5pbmRleE9mKHRydWUpICE9IC0xKXtcbiAgICAgICAgICAgIHRocm93e1xuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGAke2ZuTmFtZX0gZnVuY3Rpb24gYXJnIHBvc2l0aW9uICR7eS5pbmRleE9mKHRydWUpfSBjYW5ub3QgYmUgdW5kZWZpbmVkYFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzVHlwZSh0eXBlcyxmbk5hbWUsdCl7XG4gICAgICAgIGlzVW5kZWYoW3R5cGVzLGZuTmFtZSx0XSxmbk5hbWUpXG5cbiAgICAgICAgaWYodHlwZXMuaW5kZXhPZihmYWxzZSkgPT0gLTEpe1xuICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXJnc1BhcmFtVHlwZUVycm9yKFxuICAgICAgICAgICAgICAgIGBvbiAke2ZuTmFtZX0oKSBmdW5jdGlvbiBhcmd1bWVudCBwb3NpdGlvbiAoJHt0eXBlcy5pbmRleE9mKGZhbHNlKSArIDF9KSBjYW5ub3QgYmUgdW5kZWZpbmVkIHNob3VsZCBiZSBhICR7dFt0eXBlcy5pbmRleE9mKGZhbHNlKV19YFxuICAgICAgICAgICAgKVxuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzRW1wdHkodmFsLGZuKXtcbiAgICAgICAgaWYodmFsID09ICcnKXtcbiAgICAgICAgICAgIHRocm93IHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBgJHtmbn0gZnVuY3Rpb24gY2Fubm90IHRha2UgYW4gZW1wdHkgc3RyaW5nIGFzIGFuIGFyZ3VtZW50YFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldFNpemUocGF0aCl7XG4gICAgICAgIGxldCB0b3RhbFNpemUgID0gMCAgIFxuXG4gICAgICAgIC8vIHJlY3Vyc2lvblxuICAgICAgICBjb25zdCByZWN1ciA9IHBhdGggPT4ge1xuICAgICAgICAgICAgbGV0IGlzVGhlcmVBRGlyID0gW11cbiAgICAgICAgICAgIGZzLmxzdGF0U3luYyhwYXRoKS5pc0RpcmVjdG9yeSgpID8gKGlzVGhlcmVBRGlyID0gZnMucmVhZGRpclN5bmMocGF0aCkpIDogdG90YWxTaXplICs9IGZzLmxzdGF0U3luYyhwYXRoKS5zaXplXG4gICAgICAgICAgICBpc1RoZXJlQURpci5sZW5ndGggIT0gMCAmJiBpc1RoZXJlQURpci5tYXAoZSA9PiByZWN1cihgJHtwYXRofS8ke2V9YCkpXG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIGluaXRpYWwgY2FsbFxuICAgICAgICByZWN1cihwYXRoKVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHRvdGFsU2l6ZVxuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRDaGlsZFBhdGhzKHBhdGgpe1xuICAgICAgICBsZXQgY2hpbGRyZW4gPSB7XG4gICAgICAgICAgICBkaXI6IFtdLFxuICAgICAgICAgICAgZmlsZXM6IFtdXG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaXNEID0gZnMuc3RhdFN5bmMocGF0aCkuaXNEaXJlY3RvcnkoKSA/IHRydWUgOiBmYWxzZVxuICAgICAgICBjb25zdCBpdGVtcyA9IGlzRCA/IGZzLnJlYWRkaXJTeW5jKHBhdGgpIDogcGF0aCAgICAgICAgXG4gICAgICAgIHR5cGVvZiBpdGVtcyA9PSAnb2JqZWN0JyA/IGl0ZW1zLm1hcChlID0+IGNoaWxkcmVuLmRpci5wdXNoKGAke3BhdGh9JHtlfWApKSA6IGNoaWxkcmVuLmZpbGVzLnB1c2goaXRlbXMpXG4gICAgICAgIHJldHVybiBjaGlsZHJlblxuICAgIH1cbiAgICBmdW5jdGlvbiBzZXRDKFQpe1xuICAgICAgICBsZXQgbmV3QSA9IFtdXG4gICAgICAgIGNkID0gZnMucmVhZGRpclN5bmMoVClcbiAgICAgICAgY2QuZm9yRWFjaChjaGlsZCA9PiB7XG4gICAgICAgICAgICBjb25zdCBHID0gT2JqZWN0LmNyZWF0ZShkaXIpXG4gICAgICAgICAgICBHLm5hbWUgPSBjaGlsZFxuICAgICAgICAgICAgRy5wdWJsaWNQYXRoID0gYCR7VH0ke2NoaWxkfWBcbiAgICAgICAgICAgIEcucGFyZW50RGlyID0gVFxuICAgICAgICAgICAgRy5sYWJlbCA9ICdub25lJ1xuICAgICAgICAgICAgRy5pdGVtcyA9IGZzLmxzdGF0U3luYyhgJHtUfSR7Y2hpbGR9YCkuaXNEaXJlY3RvcnkoKSA/IEcuaXRlbXMgPSBmcy5yZWFkZGlyU3luYyhgJHtUfSR7Y2hpbGR9YCkubGVuZ3RoIDogRy5pdGVtcyA9ICdub25lJ1xuICAgICAgICAgICAgRy5zaXplID0gZ2V0U2l6ZShgJHtUfSR7Y2hpbGR9YClcbiAgICAgICAgICAgIEcuYmlydGh0aW1lID0gZnMubHN0YXRTeW5jKFQpLmJpcnRodGltZVxuICAgICAgICAgICAgRy50eXBlID0gZnMubHN0YXRTeW5jKGAke1R9LyR7Y2hpbGR9YCkuaXNEaXJlY3RvcnkoKSA/ICdmb2xkZXIvZGlyZWN0b3J5JyA6ICdmaWxlL2FwcGxpY2F0aW9uJ1xuICAgICAgICAgICAgRy5jaGlsZHJlbiA9IGdldENoaWxkUGF0aHMoYCR7VH0ke2NoaWxkfWApLmxlbmd0aCA9PSAwID8gJ25vbmUnIDogZ2V0Q2hpbGRQYXRocyhgJHtUfSR7Y2hpbGR9YClcbiAgICAgICAgICAgIEcuZmlsZUFjY2VzcyA9ICdydysnXG4gICAgICAgICAgICBpZihmcy5sc3RhdFN5bmMoIGAke1R9JHtjaGlsZH1gICkuaXNEaXJlY3RvcnkoKSApe1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBHLmZpbGVBY2Nlc3NcbiAgICAgICAgICAgICAgICBHLmZvbGRlckFjY2VzcyA9ICdydysnXG4gICAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgICAgICBkZWxldGUgRy5pdGVtc1xuICAgICAgICAgICAgICAgIEcuZmlsZUFjY2VzcyA9ICdydysnXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXdBLnB1c2goRylcbiAgICAgICAgfSlcbiAgICAgICAgY2QgPSBuZXdBXG4gICAgfVxuICAgIGNvbnN0IExheWVyID0gZnVuY3Rpb24oZGF0YSx7YmVmb3JlRW50ZXIsaGFzRW50ZXJlZCxvbkV4aXR9KSB7XG4gICAgICAgIGNvbnN0IGJFID0gYmVmb3JlRW50ZXIoZGF0YSlcbiAgICAgICAgY29uc3Qgb0UgPSBoYXNFbnRlcmVkKGJFKVxuICAgICAgICBvbkV4aXQob0UpXG4gICAgfVxuLy8gbGlic1xuICAgIFxuICAgIC8vIGEuIHNldCByb290aCBwYXRoIGRpcmVjdG9yeVxuICAgIGxpYi5jZCA9IChwYXRoKSA9PiB7ICAgICAgICBcbiAgICAgICAgaXNUeXBlKFtcbiAgICAgICAgICAgIFt0eXBlb2YgcGF0aF0gPT0gJ3N0cmluZydcbiAgICAgICAgXSwnY2QnLFsnc3RyaW5nJ10pXG4gICAgICAgIGlzRW1wdHkocGF0aCwnY2QnKVxuICAgICAgICBcbiAgICAgICAgY29uc3Qgc2FuaXRpemVkUGF0aCA9IHBhdGguZW5kc1dpdGgoJy8nKSA/IHBhdGggOiBgJHtwYXRofS9gXG4gICAgICAgIFxuICAgICAgICBpZihmcy5leGlzdHNTeW5jKHNhbml0aXplZFBhdGgpKXsgICAgICAgICAgICBcbiAgICAgICAgICAgIGxpYi5yb290UGF0aCA9IHNhbml0aXplZFBhdGhcbiAgICAgICAgICAgIHNldEMoc2FuaXRpemVkUGF0aClcbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICB0aHJvd3tcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBgY2Q6IG5vIHN1Y2ggZGlyZWN0b3J5ICR7c2FuaXRpemVkUGF0aH1gXG4gICAgICAgICAgICB9XG4gICAgICAgIH0gICAgICAgIFxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICBcbiAgICAvLyBiLiByZXR1bnJzIGFuIGFycmF5IG9mIHByb3BlcnRpZXMsIG9mIGZvbGRlciBjb250ZW50c1xuICAgIGxpYi5scyA9IChhYnNvbHV0ZVBhdGgsb3B0aW9ucykgPT4ge1xuICAgICAgICAvLyBjYXNlIDEsIGFic29sdXRlcGF0aCBpcyBvYmplY3QsIHNvIHRoZSBwYXRoIHRoYXQgd2VsbCBiZSB1c2VkXG4gICAgICAgIC8vICAgICAgICAgdG8gdHJhdmVycyB0aGUgZGlyZWN0b3J5IGlzIHRoZSBjZCBwYXRoLFxuICAgICAgICAvLyAgICAgICAgIGl0IGlzIGV4cGVjdGVkIHRoYXQgdGhlIG9iamVjdCBoYXMgb2JqZWN0IGtleXMgZm9yIG9wdGlvbnMgYXJyYXlcbiAgICAgICAgY29uc3Qgb2JqRmlyc3RBcmcgPSB0eXBlb2YgYWJzb2x1dGVQYXRoID09ICdvYmplY3QnICYmIG9wdGlvbnMgPT0gdW5kZWZpbmVkICYmIGFic29sdXRlUGF0aFxuXG4gICAgICAgIC8vIGNhc2UgMiwgYWJzb2x1dGVwYXRoIGlzIHN0cmluZywgaXQgbWVhbnMgdGhlIHVzZXIgcHJvdmlkZWQgYW4gYWJzb2x1dGUgcGF0aFxuICAgICAgICAvLyAgICAgICAgIHdoaWNoIG1lYW5zIHRoZSBjZCBwYXRoIGlmIGl0IGlzIGJlaW5nIHNldCB3aWxsIGJlIGlnbm9yZWRcbiAgICAgICAgY29uc3Qgc3RyaW5nRmlyc3RBcmcgPSB0eXBlb2YgYWJzb2x1dGVQYXRoID09ICdzdHJpbmcnICYmIG9wdGlvbnMgPT0gdW5kZWZpbmVkICYmIHRydWVcblxuICAgICAgICAvLyBjYXNlIDMsIFxuICAgICAgICBjb25zdCBjb21wbGV0ZUFyZ3MgPSB0eXBlb2YgYWJzb2x1dGVQYXRoID09ICdzdHJpbmcnICYmIHR5cGVvZiBvcHRpb25zID09ICdvYmplY3QnXG5cbiAgICAgICAgLy8gY2FzZSA0XG4gICAgICAgIGNvbnN0IGFsbFVuZGVmID0gYWJzb2x1dGVQYXRoID09IHVuZGVmaW5lZCAmJiBvcHRpb25zID09IHVuZGVmaW5lZFxuXG4gICAgICAgIC8vIG9wdGlvbnMgZXJyb3JcbiAgICAgICAgY29uc3Qgb3B0aW9uc0VyciA9IChlcnIpID0+IHt0aHJvdyB7bWVzc2FnZTogZXJyfX1cblxuICAgICAgICAvLyBzd2l0Y2ggYmFzZSBvbiB3aGF0IGNhc2UgdGhlIHVzZXIgdGFrZVxuICAgICAgICBjb25zdCBvcHRzID0gb2JqRmlyc3RBcmcgPyBvYmpGaXJzdEFyZyA6IG9wdGlvbnNcbiAgICAgICAgY29uc3Qgb3B0czIgPSBzdHJpbmdGaXJzdEFyZyA/IGFic29sdXRlUGF0aCA6IG9wdHNcbiAgICAgICAgY29uc3Qgb3B0czMgPSBjb21wbGV0ZUFyZ3MgPyBvcHRpb25zIDogb3B0czJcbiAgICAgICAgY29uc3Qgb3B0czQgPSBhbGxVbmRlZiAmJiBsaWIucm9vdFBhdGhcbiAgICAgICAgY29uc3Qgb3B0c1JlcyA9IG9wdHM0ID8gb3B0czQgOiBvcHRzM1xuICAgICAgICBcbiAgICAgICAgLy8gdG9nZ2xlIHR5cGVzXG4gICAgICAgIGxldCBjdXJyZW50VHlwZSA9ICdvYmplY3QnXG4gICAgICAgIGNvbnN0IGNoYW5nZVR5cGUgPSAodHlwZSkgPT4gY3VycmVudFR5cGUgPSB0eXBlXG4gICAgICAgIHN0cmluZ0ZpcnN0QXJnICYmIGNoYW5nZVR5cGUoJ3N0cmluZycpXG4gICAgICAgIGNvbXBsZXRlQXJncyAmJiBjaGFuZ2VUeXBlKCdvYmplY3QnKVxuICAgICAgICBhbGxVbmRlZiAmJiBjaGFuZ2VUeXBlKCdzdHJpbmcnKVxuXG4gICAgICAgIC8vIFRoaXMgdGhlIG9ubHkgYXZhaWxhYmxlIG9wdGlvbnMsIHRoaXMgaXMgdGhlIGtleXMgdGhhdCB0aGUgdXNlciB3aWxsIHByb3ZpZGVcbiAgICAgICAgY29uc3Qgb3B0aW9uc0FycmF5ID0gWydlbmRzV2l0aCcsJ3N0YXJ0c1dpdGgnLCd3aWxkQ2FyZCddXG4gICAgICAgIE9iamVjdC5zZWFsKG9wdGlvbnNBcnJheSlcblxuICAgICAgICAvLyByb290UGF0aCBpcyBub3Qgc2V0IGFuZCBhYnNvbHV0ZVBhdGggaXMgbm90XG4gICAgICAgIGxpYi5yb290UGF0aCA9PSB1bmRlZmluZWQgJiYgYWJzb2x1dGVQYXRoID09IHVuZGVmaW5lZCAmJiBvcHRpb25zRXJyKGBsczogUGF0aCBjYW5ub3QgYmUgdW5kZWZpbmVkLCBhdCBsZWFzdCBzZXQgYSByb290aFBhdGhgKVxuXG4gICAgICAgIC8vIGlmIG9wdGlvbiBpcyBub3QgYSB0eXBlIG9mIG9iamVjdCB0aHJvdyBhbiBlcnJvciB8IGxzKClcbiAgICAgICAgdHlwZW9mIG9wdHNSZXMgIT0gY3VycmVudFR5cGUgJiYgb3B0aW9uc0VycihgbHM6IE9wdGlvbnMgc2hvdWxkIGJlIGEgdHlwZSBvZiAke2N1cnJlbnRUeXBlfSBvbmx5YClcblxuICAgICAgICAvLyBpZiBvcHRpb25zIG9iamVjdCBpcyBlbXB0eSB0aHJvdyBhbiBlcnJvciB8IGxzKHt9KVxuICAgICAgICB0eXBlb2Ygb3B0cyA9PSBjdXJyZW50VHlwZSAmJiBPYmplY3Qua2V5cyhvcHRzKS5sZW5ndGggPT0gMCAmJiBvcHRpb25zRXJyKGBsaXN0RXJyb3I6IE9wdGlvbnMgJHtjdXJyZW50VHlwZX0gY2Fubm90IGJlIGVtcHR5YClcblxuICAgICAgICAvLyBpZiBvcHRpb25zIG9iamVjdCBoYXMgbW9yZSB0aGFuIG9uZSBrZXkgdGhyb3cgYW4gZXJyb3JcbiAgICAgICAgdHlwZW9mIG9wdHMgPT0gY3VycmVudFR5cGUgJiYgT2JqZWN0LmtleXMob3B0cykubGVuZ3RoICE9IDEgJiYgb3B0aW9uc0VycignbGlzdEVycm9yOiBPcHRpb25zIG9iamVjdCBjYW5ub3QgYmUgbW9yZSB0aGFuIG9uZScpXG5cbiAgICAgICAgLy8gdHlwbyBpbiB0aGUgb3B0aW9ucyBrZXlcbiAgICAgICAgdHlwZW9mIG9wdHMgPT0gY3VycmVudFR5cGUgJiYgT2JqZWN0LmtleXMob3B0cykubGVuZ3RoID09IDEgJiYgXG4gICAgICAgIG9wdGlvbnNBcnJheS5pbmRleE9mKE9iamVjdC5rZXlzKG9wdHMpWzBdKSA9PSAtMSAmJiBvcHRpb25zRXJyKGBsaXN0RXJyb3I6IFwiJHtPYmplY3Qua2V5cyhvcHRzKVswXX1cIiBpcyBub3QgcmVjb2duaXplZCwgb3B0aW9ucyBhcmUgXCIke29wdGlvbnNBcnJheX1cImApXG4gICAgICAgIFxuICAgICAgICAvLyBlbXB0eSB2YWx1ZVxuICAgICAgICB0eXBlb2Ygb3B0cyA9PSBjdXJyZW50VHlwZSAmJiBPYmplY3Qua2V5cyhvcHRzKS5sZW5ndGggPT0gMSAmJlxuICAgICAgICBvcHRpb25zQXJyYXkuaW5kZXhPZihPYmplY3Qua2V5cyhvcHRzKVswXSkgIT0gLTEgJiYgb3B0c1tPYmplY3Qua2V5cyhvcHRzKVswXV0gPT0gJycgJiYgXG4gICAgICAgIG9wdGlvbnNFcnIoJ2xpc3RFcnJvcjogT3B0aW9ucyB2YWx1ZSBjYW5ub3QgYmUgYW4gZW1wdHkgc3RyaW5nJylcblxuICAgICAgICAvLyBub3QgYSBzdHJpbmcgdmFsdWVcbiAgICAgICAgdHlwZW9mIG9wdHMgPT0gJ29iamVjdCcgJiYgT2JqZWN0LmtleXMob3B0cykubGVuZ3RoID09IDEgJiZcbiAgICAgICAgb3B0aW9uc0FycmF5LmluZGV4T2YoT2JqZWN0LmtleXMob3B0cylbMF0pICE9IC0xICYmIHR5cGVvZiBvcHRzW09iamVjdC5rZXlzKG9wdHMpWzBdXSAhPSAnc3RyaW5nJyAmJiBcbiAgICAgICAgb3B0aW9uc0VycignbGlzdEVycm9yOiBPcHRpb25zIHZhbHVlIHR5cGUgc2hvdWxkIGJlIGEgc3RyaW5nJylcblxuICAgICAgICAvLyBDb250YWluZXIgdGhhdCB3aWxsIGJlIHVzZSB0byBiZSBtdXRhdGVkIGxhdGVyLCB1c2VkIHRvIGZvciByZXR1cm4gb2YgdGhlIGRhdGFcbiAgICAgICAgbGV0IHJlcyA9IHVuZGVmaW5lZFxuXG4gICAgICAgIC8vIHJldHVybmVkIG1ldGhvZHNcbiAgICAgICAgbGV0IG1ldGhvZHMgPSB7fVxuXG4gICAgICAgIC8vIG1vZGVzIFxuICAgICAgICBjb25zdCBtb2RlcyA9IFsnYXNjJywnZGVjJ11cblxuICAgICAgICAvLyBVc2VEYXRhXG4gICAgICAgIGxldCBVc2VyRGF0YSA9IHVuZGVmaW5lZFxuICAgICAgICBvYmpGaXJzdEFyZyAgICAgJiYgKFVzZXJEYXRhID0ge3BhdGg6IGxpYi5yb290UGF0aCwgb3B0aW9uczphYnNvbHV0ZVBhdGh9KVxuICAgICAgICAvLyBzdHJpbmdGaXJzdEFyZyAgJiYgKFVzZXJEYXRhID0ge3BhdGg6IGFic29sdXRlUGF0aC5lbmRzV2l0aCgnLycpID8gYWJzb2x1dGVQYXRoIDogYCR7YWJzb2x1dGVQYXRofS9gLCBvcHRpb25zOnVuZGVmaW5lZH0pXG5cbiAgICAgICAgLy8gd2hhdCBpZiBjZCBsaW5rIGhhcyB0aGUgc2FtZSBsaW5rIGFzIGxzID8gXG4gICAgICAgIGNvbnN0IHN0ckZpcnN0QXJnQzEgPSB0eXBlb2YgbGliLnJvb3RQYXRoID09ICdzdHJpbmcnICYmIHR5cGVvZiBhYnNvbHV0ZVBhdGggPT0gJ3N0cmluZydcbiAgICAgICAgY29uc3Qgc3RyRmlyc3RBcmdDMiA9IHN0ckZpcnN0QXJnQzEgJiYgbGliLnJvb3RQYXRoID09IGFic29sdXRlUGF0aCA/IHRydWUgOiBmYWxzZVxuICAgICAgICBjb25zdCBzdHJGaXJzdEFyZ0MzID0gc3RyRmlyc3RBcmdDMiA/IGFic29sdXRlUGF0aCA6IGAke2xpYi5yb290UGF0aCA9PSB1bmRlZmluZWQgPyAnJyA6IGxpYi5yb290UGF0aH0ke2Fic29sdXRlUGF0aH1gXG5cbiAgICAgICAgLy8gYXNzaWduIGNvcnJlY3QgZGF0YVxuICAgICAgICBzdHJpbmdGaXJzdEFyZyAgJiYgKFVzZXJEYXRhID0ge3BhdGg6IHN0ckZpcnN0QXJnQzMuZW5kc1dpdGgoJy8nKSA/IHN0ckZpcnN0QXJnQzMgOiBgJHtzdHJGaXJzdEFyZ0MzfS9gLCBvcHRpb25zOnVuZGVmaW5lZH0pXG4gICAgICAgIGNvbXBsZXRlQXJncyAgICAmJiAoVXNlckRhdGEgPSB7cGF0aDogc3RyRmlyc3RBcmdDMy5lbmRzV2l0aCgnLycpID8gc3RyRmlyc3RBcmdDMyA6IGAke3N0ckZpcnN0QXJnQzN9L2AsIG9wdGlvbnN9KVxuICAgICAgICBhbGxVbmRlZiAgICAgICAgJiYgKFVzZXJEYXRhID0ge3BhdGg6IGxpYi5yb290UGF0aCwgb3B0aW9uczpvcHRpb25zfSlcblxuICAgICAgICAvLyBDb250ZW50c1xuICAgICAgICBsZXQgY29udGVudHMgPSBbXVxuICAgICAgICBjb25zdCBkb2VzUGF0aEV4aXN0ID0gZnMuZXhpc3RzU3luYyhVc2VyRGF0YS5wYXRoKVxuICAgICAgICBpZighZG9lc1BhdGhFeGlzdCl7dGhyb3cgbmV3IFBhdGhEb2VzTm90RXhpc3RFcnJvcihgb24gbHM6IG5vIHN1Y2ggZGlyZWN0b3J5ICR7VXNlckRhdGEucGF0aH1gKX1cbiAgICAgICAgZG9lc1BhdGhFeGlzdCAmJiBzZXRDKFVzZXJEYXRhLnBhdGgpXG5cbiAgICAgICAgcmV0dXJuIGNkXG4gICAgfVxuXG4gICAgLy9cbiAgICBsaWIudG91Y2ggPSAoZmlsZSkgPT4ge1xuICAgICAgICAvLyBzYW5pdGl6aW5nXG4gICAgICAgIGZpbGUgPT0gdW5kZWZpbmVkICYmIGVycignZXJyb3IgdG91Y2g6IHRvdWNoIHBhcmFtZXRlciBjYW5ub3QgYmUgdW5kZWZpbmVkJylcbiAgICAgICAgdHlwZW9mIGZpbGUgIT0gJ3N0cmluZycgJiYgZmlsZVswXSA9PSB1bmRlZmluZWQgJiYgZXJyKCdlcnJvciB0b3VjaDogaW52YWxpZCB0cHllIGluIHBhcmFtZXRlciBzaG91bGQgYmUgYSBzdHJpbmcgb3IgYXJyYXknKVxuXG5cbiAgICAgICAgY29uc3QgYzEgPSAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBvcmlnaW5QYXRoID0gT2JqZWN0LmtleXMoIHF1ZXJ5U3RyaW5nLnBhcnNlKGZpbGUsJy8nKSApXG4gICAgICAgICAgICBjb25zdCBwYXRoTGVuID0gb3JpZ2luUGF0aC5sZW5ndGggLSAxXG4gICAgICAgICAgICBjb25zdCBwYXRoRmlsZSA9IGAvJHtvcmlnaW5QYXRoLnNwbGljZShwYXRoTGVuLDEpWzBdfWBcbiAgICAgICAgICAgIG9yaWdpblBhdGguc3BsaWNlKHBhdGhMZW4sMSlcbiAgICAgICAgICAgIGxldCBuZXdQYXRoID0gJydcbiAgICAgICAgICAgIG9yaWdpblBhdGgubWFwKGUgPT4gbmV3UGF0aCArPSBgLyR7ZX1gKVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBmcy5leGlzdHNTeW5jKG5ld1BhdGgpID8gXG4gICAgICAgICAgICAgICAgZnMuZXhpc3RzU3luYyhgJHtuZXdQYXRofSR7cGF0aEZpbGV9YCkgPyBlcnIoYCR7cGF0aEZpbGV9IGFscmVhZHkgZXhpc3QgaW4gJHtuZXdQYXRofSBkaXJlY3RvcnlgKSA6IFxuICAgICAgICAgICAgICAgIGZzLndyaXRlRmlsZVN5bmMoYCR7bmV3UGF0aH0ke3BhdGhGaWxlfWApXG4gICAgICAgICAgICA6ICBlcnIoYHRoZXJlIGlzIG5vIHN1Y2ggZGlyZWN0b3J5ICR7bmV3UGF0aH1gKVxuXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgJHtuZXdQYXRofSR7cGF0aEZpbGV9YClcbiAgICAgICAgfVxuXG4gICAgICAgIGMxKClcbiAgICAgICAgXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKGAke2ZpbGV9IC0tPiAke2xpYi5yb290UGF0aH1gKVxuICAgICAgICBcbiAgICAgICAgLy8gY2hlY2tpbmcgZXhpc3RhbmNjZVxuICAgICAgICBcbiAgICB9XG5cbiAgICAvLyBjLiBta2RpciBjcmVhdGVzIG5ldyBkaXJlY3RvcnlcbiAgICAvLyBjLmNhc2VzIDogbWtkaXIoW10pIC0tPiBhY2NlcHRzIGFycmF5IGFzIGFuIGFydWd1bWVudCBhcyBmb2xkZXIgbmFtZXMgfCBtYXNzIGZvbGRlciBjcmVhdGlvblxuICAgIC8vIGMuY2FzZXMgOiBta2RpcignJykgLS0+IGFjY2VwdHMgc3RyaW5nIHwgc2luZ2xlIGRpciBjcmVhdGlvblxuICAgIGxpYi5ta2RpciA9IChwYXRoKSA9PiB7XG5cbiAgICB9XG5cbiAgICBkZWxldGUgbGliLnJvb3RQYXRoXG4gICAgcmV0dXJuIGxpYlxufSkoKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGQiXX0=